/**
 * @famgia/omnify-types - Internationalization (i18n) Types
 *
 * Types for multi-language support in schema definitions.
 * Supports displayName, description, and other localizable strings.
 */
/**
 * Supported locale code format (ISO 639-1 language codes).
 * Examples: 'en', 'ja', 'vi', 'zh', 'ko', 'fr', 'de', 'es', 'pt'
 */
type LocaleCode = string;
/**
 * Map of locale codes to localized strings.
 * @example { en: 'User Name', ja: 'ユーザー名', vi: 'Tên người dùng' }
 */
type LocaleMap = Readonly<Record<LocaleCode, string>>;
/**
 * Localized string - can be either a simple string (default locale)
 * or a map of locale codes to localized strings.
 *
 * @example
 * // Simple string (uses default locale)
 * displayName: "User Name"
 *
 * // Multi-language object
 * displayName:
 *   en: "User Name"
 *   ja: "ユーザー名"
 *   vi: "Tên người dùng"
 */
type LocalizedString = string | LocaleMap;
/**
 * Validation message templates.
 * Use placeholders: ${displayName}, ${min}, ${max}, ${length}, ${pattern}
 */
interface ValidationMessages {
    readonly required?: LocaleMap;
    readonly minLength?: LocaleMap;
    readonly maxLength?: LocaleMap;
    readonly min?: LocaleMap;
    readonly max?: LocaleMap;
    readonly email?: LocaleMap;
    readonly url?: LocaleMap;
    readonly pattern?: LocaleMap;
    readonly [key: string]: LocaleMap | undefined;
}
/**
 * Locale configuration for omnify projects.
 * Configured in .omnify.yaml or omnify.config.ts
 */
interface LocaleConfig {
    /**
     * List of supported locale codes.
     * @default ['en']
     * @example ['en', 'ja', 'vi']
     */
    readonly locales: readonly LocaleCode[];
    /**
     * Default locale code used when:
     * - displayName is a simple string
     * - Requested locale is not found and no fallback matches
     * @default 'en'
     */
    readonly defaultLocale: LocaleCode;
    /**
     * Fallback locale code used when requested locale is not found.
     * If not set, falls back to defaultLocale.
     * @example 'en' - If 'ko' not found, try 'en' before defaultLocale
     */
    readonly fallbackLocale?: LocaleCode;
    /**
     * Custom validation messages.
     * Override default messages or add new languages.
     *
     * @example
     * messages: {
     *   required: {
     *     ja: '${displayName}は必須です',
     *     en: '${displayName} is required',
     *     ko: '${displayName}은(는) 필수입니다',
     *   },
     *   maxLength: {
     *     ja: '${displayName}は${max}文字以内で入力してください',
     *     en: '${displayName} must be at most ${max} characters',
     *   },
     * }
     */
    readonly messages?: ValidationMessages;
}
/**
 * Default locale configuration.
 */
declare const DEFAULT_LOCALE_CONFIG: LocaleConfig;
/**
 * Options for resolving localized strings.
 */
interface LocaleResolutionOptions {
    /**
     * Locale to resolve to.
     * If not provided, uses defaultLocale from config.
     */
    readonly locale?: LocaleCode;
    /**
     * Locale configuration.
     * If not provided, uses DEFAULT_LOCALE_CONFIG.
     */
    readonly config?: LocaleConfig;
    /**
     * Whether to throw an error if locale is not found.
     * If false, returns undefined for missing locales.
     * @default false
     */
    readonly strict?: boolean;
}
/**
 * Check if a value is a LocaleMap (object with locale keys).
 */
declare function isLocaleMap(value: unknown): value is LocaleMap;
/**
 * Check if a value is a LocalizedString.
 */
declare function isLocalizedString(value: unknown): value is LocalizedString;
/**
 * Resolve a localized string to a specific locale.
 *
 * Resolution order:
 * 1. Requested locale (if provided)
 * 2. Fallback locale (if configured)
 * 3. Default locale
 * 4. First available locale (if none of the above match)
 * 5. undefined (if strict=false) or throws error (if strict=true)
 *
 * @param value - The localized string value
 * @param options - Resolution options
 * @returns The resolved string or undefined
 *
 * @example
 * // Simple string
 * resolveLocalizedString('Hello') // => 'Hello'
 *
 * // Multi-language with locale
 * resolveLocalizedString({ en: 'Hello', ja: 'こんにちは' }, { locale: 'ja' })
 * // => 'こんにちは'
 *
 * // Multi-language with fallback
 * resolveLocalizedString({ en: 'Hello', ja: 'こんにちは' }, { locale: 'ko' })
 * // => 'Hello' (falls back to defaultLocale)
 */
declare function resolveLocalizedString(value: LocalizedString | undefined | null, options?: LocaleResolutionOptions): string | undefined;
/**
 * Get all available locales from a localized string.
 *
 * @param value - The localized string value
 * @returns Array of available locale codes, or ['default'] for simple strings
 */
declare function getAvailableLocales(value: LocalizedString | undefined | null): readonly LocaleCode[];
/**
 * Convert a localized string to a full LocaleMap.
 * Simple strings are converted to { [defaultLocale]: value }.
 *
 * @param value - The localized string value
 * @param defaultLocale - Default locale for simple strings
 * @returns LocaleMap or undefined
 */
declare function toLocaleMap(value: LocalizedString | undefined | null, defaultLocale?: LocaleCode): LocaleMap | undefined;
/**
 * Merge two localized strings, with the second taking precedence.
 *
 * @param base - Base localized string
 * @param override - Override localized string
 * @param defaultLocale - Default locale for simple strings
 * @returns Merged LocaleMap
 */
declare function mergeLocalizedStrings(base: LocalizedString | undefined | null, override: LocalizedString | undefined | null, defaultLocale?: LocaleCode): LocaleMap | undefined;

/**
 * @famgia/omnify-types - Plugin Types
 *
 * Type definitions for omnify plugins that provide custom types.
 */

/**
 * SQL column definition for a custom type.
 */
interface SqlColumnDefinition {
    /** SQL type (e.g., 'VARCHAR', 'INT', 'TEXT') */
    readonly sqlType: string;
    /** Column length/size if applicable */
    readonly length?: number;
    /** Precision for decimal types */
    readonly precision?: number;
    /** Scale for decimal types */
    readonly scale?: number;
    /** Whether the column is nullable */
    readonly nullable?: boolean;
    /** Default value */
    readonly default?: unknown;
    /** Whether the column is unsigned (for integer types) */
    readonly unsigned?: boolean;
}
/**
 * TypeScript type information for code generation.
 */
interface TypeScriptTypeInfo {
    /** TypeScript type as a string (e.g., 'string', 'number', 'MyCustomType') */
    readonly type: string;
    /** Whether to import this type from somewhere */
    readonly import?: {
        readonly from: string;
        readonly name: string;
    };
}
/**
 * Validation rules for a field.
 * These are applied at the Zod schema level.
 */
interface FieldValidationRules {
    /** Minimum length for strings */
    readonly minLength?: number;
    /** Maximum length for strings (defaults to sql.length if not set) */
    readonly maxLength?: number;
    /** Minimum value for numbers */
    readonly min?: number;
    /** Maximum value for numbers */
    readonly max?: number;
    /** Regex pattern for string validation */
    readonly pattern?: string;
    /** Built-in format validators */
    readonly format?: 'email' | 'url' | 'phone' | 'postal_code';
}
/**
 * Expanded field definition for compound types.
 * Used when a single custom type expands to multiple database columns.
 */
interface ExpandedFieldDefinition {
    /** Field name suffix (appended to property name) */
    readonly suffix: string;
    /** SQL column definition (ignored if enumRef is set) */
    readonly sql?: SqlColumnDefinition;
    /** TypeScript type for this field (ignored if enumRef is set) */
    readonly typescript?: TypeScriptTypeInfo;
    /** Reference to a shared enum schema (overrides sql/typescript) */
    readonly enumRef?: string;
    /** Laravel cast type for this field */
    readonly cast?: string;
    /** Default nullable for this field (can be overridden in schema) */
    readonly nullable?: boolean;
    /**
     * Validation rules for this field.
     * Can be overridden in schema via fields.{suffix}.rules
     *
     * @example
     * rules: {
     *   minLength: 1,
     *   maxLength: 100,
     *   pattern: '^[ァ-ヶー]+$'  // Katakana only
     * }
     */
    readonly rules?: FieldValidationRules;
    /**
     * Default label for this field (supports multi-language).
     * Can be overridden in schema via fields.{suffix}.displayName
     *
     * @example
     * label: {
     *   en: "Last Name",
     *   ja: "姓",
     *   vi: "Họ"
     * }
     */
    readonly label?: LocalizedString;
    /**
     * Default placeholder for this field (supports multi-language).
     * Can be overridden in schema via fields.{suffix}.placeholder
     *
     * @example
     * placeholder: {
     *   en: "e.g. Yamada",
     *   ja: "例：山田",
     *   vi: "VD: Nguyễn"
     * }
     */
    readonly placeholder?: LocalizedString;
}
/**
 * Accessor definition for compound types.
 * Defines computed properties that combine multiple fields.
 */
interface CompoundTypeAccessor {
    /** Accessor name (will be used as attribute name, e.g., 'full_name') */
    readonly name: string;
    /**
     * Fields to combine (suffixes without underscore prefix).
     * e.g., ['last_name', 'first_name']
     */
    readonly fields: readonly string[];
    /**
     * Separator between fields.
     * @default ' '
     */
    readonly separator?: string;
    /**
     * Order of fields (if different from definition order).
     * Use field suffixes. If not specified, uses `fields` order.
     */
    readonly order?: readonly string[];
}
/**
 * Definition of a custom property type provided by a plugin.
 */
interface CustomTypeDefinition {
    /** Type name as used in schema files (e.g., 'JapanesePhone') */
    readonly name: string;
    /**
     * Description of this custom type.
     */
    readonly description?: string;
    /**
     * Whether this is a compound type that expands to multiple columns.
     * If true, use `expand` to define the columns.
     * If false or undefined, use `sql` and `typescript` for single column.
     */
    readonly compound?: boolean;
    /**
     * SQL column definition (for single-column types).
     */
    readonly sql?: SqlColumnDefinition;
    /**
     * TypeScript type info (for single-column types).
     */
    readonly typescript?: TypeScriptTypeInfo;
    /**
     * Expanded field definitions (for compound types).
     * Each entry creates an additional column.
     */
    readonly expand?: readonly ExpandedFieldDefinition[];
    /**
     * Accessor definitions for compound types.
     * Creates computed properties that combine multiple fields.
     * In Laravel, generates get{Name}Attribute() methods.
     *
     * @example
     * accessors: [
     *   { name: 'full_name', fields: ['last_name', 'first_name'] },
     *   { name: 'full_name_kana', fields: ['last_name_kana', 'first_name_kana'] },
     * ]
     */
    readonly accessors?: readonly CompoundTypeAccessor[];
    /**
     * Additional fields valid for this custom type (beyond base fields).
     * Base fields (type, displayName, nullable, default, unique, description, renamedFrom)
     * are always allowed. Add type-specific fields here.
     *
     * @example
     * // For a type that accepts 'format' field:
     * validFields: ['format']
     */
    readonly validFields?: readonly string[];
    /**
     * Validation function for schema validation.
     * @param value - The property definition using this type
     * @returns Error message if invalid, undefined if valid
     */
    readonly validate?: (value: PropertyDefinition) => string | undefined;
}
/**
 * Plugin context provided during plugin initialization.
 */
interface PluginContext {
    /** Current working directory */
    readonly cwd: string;
    /** Whether verbose logging is enabled */
    readonly verbose: boolean;
    /** Logger for plugin output */
    readonly logger: PluginLogger;
}
/**
 * Logger interface for plugin output.
 */
interface PluginLogger {
    /** Log debug message (only in verbose mode) */
    debug(message: string): void;
    /** Log info message */
    info(message: string): void;
    /** Log warning message */
    warn(message: string): void;
    /** Log error message */
    error(message: string): void;
}
/**
 * Plugin interface for extending omnify with custom types.
 *
 * @example
 * ```typescript
 * const japanTypesPlugin: OmnifyPlugin = {
 *   name: '@famgia/omnify-japan',
 *   version: '1.0.0',
 *   types: [
 *     {
 *       name: 'JapanesePhone',
 *       sql: { sqlType: 'VARCHAR', length: 15 },
 *       typescript: { type: 'string' },
 *     },
 *     {
 *       name: 'JapaneseAddress',
 *       compound: true,
 *       expand: [
 *         { suffix: '_postal', sql: { sqlType: 'VARCHAR', length: 8 }, typescript: { type: 'string' } },
 *         { suffix: '_prefecture', sql: { sqlType: 'VARCHAR', length: 10 }, typescript: { type: 'string' } },
 *         { suffix: '_city', sql: { sqlType: 'VARCHAR', length: 100 }, typescript: { type: 'string' } },
 *         { suffix: '_address', sql: { sqlType: 'VARCHAR', length: 255 }, typescript: { type: 'string' } },
 *       ],
 *     },
 *   ],
 * };
 * ```
 */
/**
 * Enum definition provided by a plugin.
 */
interface PluginEnumDefinition {
    /** Enum name (used as schema name) */
    readonly name: string;
    /** Human-readable display name (supports multi-language) */
    readonly displayName?: LocalizedString;
    /** Description of the enum */
    readonly description?: string;
    /** Enum values */
    readonly values: readonly PluginEnumValue[];
}
/**
 * Enum value definition.
 */
interface PluginEnumValue {
    /** Value stored in database */
    readonly value: string;
    /** Human-readable label (supports multi-language) */
    readonly label: LocalizedString;
    /** Extra properties for this enum value */
    readonly extra?: Record<string, string | number | boolean>;
}
interface OmnifyPlugin {
    /** Plugin name (typically npm package name) */
    readonly name: string;
    /** Plugin version */
    readonly version: string;
    /** Human-readable description for GUI display */
    readonly description?: string;
    /**
     * Configuration schema for GUI rendering (WordPress-like).
     * Describes what options the plugin accepts.
     */
    readonly configSchema?: PluginConfigSchema;
    /**
     * Custom type definitions provided by this plugin.
     */
    readonly types?: readonly CustomTypeDefinition[];
    /**
     * Enum schemas provided by this plugin.
     * These are automatically available for EnumRef without user creating them.
     */
    readonly enums?: readonly PluginEnumDefinition[];
    /**
     * Generator definitions provided by this plugin.
     * Generators produce output files (migrations, types, models, etc.)
     */
    readonly generators?: readonly GeneratorDefinition[];
    /**
     * Optional setup function called when plugin is loaded.
     * @param context - Plugin context with utilities
     */
    readonly setup?: (context: PluginContext) => void | Promise<void>;
    /**
     * Optional cleanup function called when plugin is unloaded.
     */
    readonly teardown?: () => void | Promise<void>;
}
/**
 * Factory function type for creating plugins.
 * Useful for plugins that need configuration.
 */
type PluginFactory<TOptions = unknown> = (options?: TOptions) => OmnifyPlugin;
/**
 * Output type for generated files.
 */
type GeneratorOutputType = 'migration' | 'type' | 'model' | 'factory' | 'schema' | 'other';
/**
 * Output from a generator - represents a file to be written.
 */
interface GeneratorOutput {
    /** Relative path where the file should be written */
    readonly path: string;
    /** Content of the file */
    readonly content: string;
    /** Type of output for categorization */
    readonly type: GeneratorOutputType;
    /** Skip writing if file already exists (useful for user-customizable files) */
    readonly skipIfExists?: boolean;
    /** Optional metadata */
    readonly metadata?: Record<string, unknown>;
}
/**
 * Schema change type.
 */
type SchemaChangeType = 'added' | 'modified' | 'removed';
/**
 * Property snapshot for schema change detection.
 */
interface PropertySnapshot {
    readonly type: string;
    readonly nullable?: boolean | undefined;
    readonly unique?: boolean | undefined;
    readonly default?: unknown;
    readonly length?: number | undefined;
    readonly unsigned?: boolean | undefined;
    readonly precision?: number | undefined;
    readonly scale?: number | undefined;
    readonly enum?: readonly string[] | undefined;
    readonly relation?: string | undefined;
    readonly target?: string | undefined;
    readonly onDelete?: string | undefined;
    readonly onUpdate?: string | undefined;
}
/**
 * Index snapshot for change detection.
 */
interface IndexSnapshot {
    readonly columns: readonly string[];
    readonly unique: boolean;
    readonly name?: string | undefined;
}
/**
 * Column change details for migration generation.
 */
interface ColumnChange {
    /** Column name */
    readonly column: string;
    /** Type of change */
    readonly changeType: 'added' | 'removed' | 'modified' | 'renamed';
    /** Previous property definition (for removed/modified columns) */
    readonly previousDef?: PropertySnapshot | undefined;
    /** Current property definition (for added/modified columns) */
    readonly currentDef?: PropertySnapshot | undefined;
    /** Previous column name (for renamed columns) */
    readonly previousColumn?: string | undefined;
    /** Specific modifications (e.g., 'type', 'nullable', 'default') */
    readonly modifications?: readonly string[] | undefined;
}
/**
 * Index change details.
 */
interface IndexChange {
    /** Type of change */
    readonly changeType: 'added' | 'removed';
    /** Index definition */
    readonly index: IndexSnapshot;
}
/**
 * Schema change information for migration generation.
 */
interface SchemaChange {
    /** Schema name */
    readonly schemaName: string;
    /** Type of change */
    readonly changeType: SchemaChangeType;
    /** Column-level changes (for modified schemas) */
    readonly columnChanges?: readonly ColumnChange[] | undefined;
    /** Index-level changes (for modified schemas) */
    readonly indexChanges?: readonly IndexChange[] | undefined;
    /** Options changes (timestamps, softDelete, etc.) */
    readonly optionChanges?: {
        readonly timestamps?: {
            from?: boolean;
            to?: boolean;
        };
        readonly softDelete?: {
            from?: boolean;
            to?: boolean;
        };
    } | undefined;
}
/**
 * Context provided to generators during execution.
 */
interface GeneratorContext {
    /** Loaded and validated schema collection */
    readonly schemas: SchemaCollection;
    /** Schema changes detected from lock file comparison */
    readonly changes?: readonly SchemaChange[] | undefined;
    /** Plugin-specific configuration (passed to plugin factory) */
    readonly pluginConfig: Record<string, unknown>;
    /** Current working directory */
    readonly cwd: string;
    /** Logger for output */
    readonly logger: PluginLogger;
    /** Outputs from previously run generators (for dependencies) */
    readonly previousOutputs: ReadonlyMap<string, readonly GeneratorOutput[]>;
    /** Custom types registered by all plugins (for compound type expansion) */
    readonly customTypes: ReadonlyMap<string, CustomTypeDefinition>;
    /** Enums registered by all plugins (e.g., Prefecture, BankAccountType) */
    readonly pluginEnums: ReadonlyMap<string, PluginEnumDefinition>;
    /** Locale configuration for multi-language support */
    readonly localeConfig?: LocaleConfig | undefined;
}
/**
 * Definition of a generator provided by a plugin.
 *
 * @example
 * ```typescript
 * const migrationGenerator: GeneratorDefinition = {
 *   name: 'laravel-migrations',
 *   description: 'Generate Laravel migration files',
 *   generate: async (ctx) => {
 *     const migrations = generateMigrations(ctx.schemas);
 *     return migrations.map(m => ({
 *       path: `database/migrations/${m.fileName}`,
 *       content: m.content,
 *       type: 'migration',
 *     }));
 *   },
 * };
 * ```
 */
interface GeneratorDefinition {
    /** Unique generator name (e.g., 'laravel-migrations') */
    readonly name: string;
    /** Human-readable description */
    readonly description?: string;
    /**
     * Dependencies on other generators.
     * This generator will run after all dependencies have completed.
     * Used for topological sorting (DAG).
     */
    readonly dependsOn?: readonly string[];
    /**
     * Generator function.
     * @param ctx - Generator context with schemas and configuration
     * @returns Array of files to generate
     */
    readonly generate: (ctx: GeneratorContext) => GeneratorOutput[] | Promise<GeneratorOutput[]>;
}
/**
 * Field types for plugin configuration.
 */
type PluginConfigFieldType = 'string' | 'boolean' | 'number' | 'select' | 'path';
/**
 * Select option for config fields.
 */
interface PluginConfigSelectOption {
    readonly value: string;
    readonly label: string;
}
/**
 * Single configuration field definition.
 */
interface PluginConfigField {
    /** Field key (matches option key in plugin options) */
    readonly key: string;
    /** Field type */
    readonly type: PluginConfigFieldType;
    /** Human-readable label */
    readonly label: string;
    /** Optional description/help text */
    readonly description?: string;
    /** Default value */
    readonly default?: unknown;
    /** Whether this field is required */
    readonly required?: boolean;
    /** For 'select' type: available options */
    readonly options?: readonly PluginConfigSelectOption[];
    /** Placeholder text for string/path inputs */
    readonly placeholder?: string;
    /** Group name for organizing fields */
    readonly group?: string;
}
/**
 * Plugin configuration schema.
 * Describes what options the plugin accepts for GUI rendering.
 */
interface PluginConfigSchema {
    /** Array of configuration fields */
    readonly fields: readonly PluginConfigField[];
}

/**
 * @famgia/omnify-types - Configuration Types
 *
 * Type definitions for omnify.config.ts configuration file.
 */

/**
 * Supported database drivers.
 */
type DatabaseDriver = 'mysql' | 'pgsql' | 'postgres' | 'sqlite' | 'sqlsrv' | 'mariadb';
/**
 * Database configuration for Atlas and migrations.
 */
interface DatabaseConfig {
    /** Database driver type */
    readonly driver: DatabaseDriver;
    /** Development database URL for Atlas diff operations */
    readonly devUrl?: string;
    /** Enable field comments in migrations (MySQL only) */
    readonly enableFieldComments?: boolean;
}
/**
 * Laravel output configuration.
 */
interface LaravelOutputConfig {
    /** Directory for generated migration files */
    readonly migrationsPath: string;
    /** Directory for generated model files */
    readonly modelsPath?: string;
    /** Directory for generated base model files (auto-generated, always overwritten) */
    readonly baseModelsPath?: string;
    /** Directory for generated service provider files */
    readonly providersPath?: string;
    /** Model namespace */
    readonly modelsNamespace?: string;
    /** Directory for generated factory files */
    readonly factoriesPath?: string;
    /** Directory for generated enum files */
    readonly enumsPath?: string;
    /** Enum namespace */
    readonly enumsNamespace?: string;
}
/**
 * TypeScript output configuration.
 */
interface TypeScriptOutputConfig {
    /**
     * Base output directory for all TypeScript files.
     * Schemas and enums will be placed in subdirectories.
     * @example 'resources/ts/omnify'
     */
    readonly path: string;
    /**
     * Subdirectory for schema files (interfaces, Zod schemas, i18n).
     * Relative to `path`.
     * @default 'schemas'
     * @example 'models' - places schemas at {path}/models/
     */
    readonly schemasDir?: string;
    /**
     * Subdirectory for enum files.
     * Relative to `path`.
     * @default 'enum'
     * @example 'enums' - places enums at {path}/enums/
     */
    readonly enumDir?: string;
    /** Whether to generate a single file or multiple files */
    readonly singleFile?: boolean;
    /** Whether to generate enum types */
    readonly generateEnums?: boolean;
    /** Whether to generate relationship types */
    readonly generateRelationships?: boolean;
}
/**
 * Combined output configuration.
 */
interface OutputConfig {
    /** Laravel migration and model output */
    readonly laravel?: LaravelOutputConfig;
    /** TypeScript type definitions output */
    readonly typescript?: TypeScriptOutputConfig;
}
/**
 * Package-level Laravel output configuration.
 * Allows packages to define their own output paths and namespaces.
 */
interface PackageLaravelOutputConfig {
    /**
     * Base path for all package outputs (relative to project root).
     * @example './packages/sso-client'
     */
    readonly base: string;
    /**
     * Model namespace for the package.
     * @example 'Omnify\\SsoClient\\Models'
     */
    readonly modelsNamespace: string;
    /**
     * Path for user-editable models (relative to base).
     * @default 'src/Models'
     */
    readonly modelsPath?: string;
    /**
     * Path for auto-generated base models (relative to base).
     * @default 'src/Models/OmnifyBase'
     */
    readonly baseModelsPath?: string;
    /**
     * Base model namespace.
     * @default derived from modelsNamespace + '\\Generated'
     */
    readonly baseModelsNamespace?: string;
    /**
     * Path for migrations (relative to base).
     * @default 'database/migrations'
     */
    readonly migrationsPath?: string;
    /**
     * Path for enums (relative to base).
     * @default 'src/Enums'
     */
    readonly enumsPath?: string;
    /**
     * Enum namespace.
     * @default derived from modelsNamespace parent + '\\Enums'
     */
    readonly enumsNamespace?: string;
    /**
     * Whether to generate a service provider for auto-discovery.
     * @default true
     */
    readonly generateServiceProvider?: boolean;
    /**
     * Path for service provider (relative to base).
     * @default 'src/Providers'
     */
    readonly providersPath?: string;
    /**
     * Service provider namespace.
     * @default derived from modelsNamespace parent + '\\Providers'
     */
    readonly providersNamespace?: string;
    /**
     * Whether to generate factories for the package.
     * @default true
     */
    readonly generateFactories?: boolean;
    /**
     * Path for factories (relative to base).
     * @default 'database/factories'
     */
    readonly factoriesPath?: string;
}
/**
 * Package-level output configuration.
 */
interface PackageOutputConfig {
    /** Laravel output configuration for the package */
    readonly laravel?: PackageLaravelOutputConfig;
}
/**
 * Additional schema path entry for loading schemas from packages.
 */
interface AdditionalSchemaPath {
    /**
     * Path to the schema directory.
     * Can be relative (from project root) or absolute.
     * @example './packages/sso-client/database/schemas'
     */
    readonly path: string;
    /**
     * Optional namespace prefix for schemas from this path.
     * Used for organizing schemas from different packages.
     * @example 'Sso'
     */
    readonly namespace?: string;
    /**
     * Package-level output configuration.
     * When set, generated files for schemas from this path will be placed
     * in the package directory with custom namespaces.
     *
     * @example
     * output: {
     *   laravel: {
     *     base: './packages/sso-client',
     *     modelsNamespace: 'Omnify\\SsoClient\\Models',
     *   }
     * }
     */
    readonly output?: PackageOutputConfig;
}
/**
 * Main omnify configuration interface.
 * Used in omnify.config.ts files.
 */
interface OmnifyConfig {
    /**
     * Directory containing schema definition files.
     * @default './schemas'
     */
    readonly schemasDir?: string;
    /**
     * Additional schema paths from packages or other directories.
     * Schemas from these paths will be merged with the main schemasDir.
     * Package schemas won't override main schemas with the same name.
     *
     * @example
     * additionalSchemaPaths: [
     *   { path: './packages/sso-client/database/schemas', namespace: 'Sso' },
     *   { path: './packages/billing/schemas', namespace: 'Billing' },
     * ]
     */
    readonly additionalSchemaPaths?: readonly AdditionalSchemaPath[];
    /**
     * Database configuration.
     */
    readonly database: DatabaseConfig;
    /**
     * Output configuration for generated files.
     */
    readonly output?: OutputConfig;
    /**
     * Plugins to load for custom types.
     * Can be npm package names or plugin objects.
     */
    readonly plugins?: readonly (string | OmnifyPlugin)[];
    /**
     * Enable verbose logging.
     * @default false
     */
    readonly verbose?: boolean;
    /**
     * Lock file path for tracking schema state.
     * @default '.omnify.lock'
     */
    readonly lockFilePath?: string;
    /**
     * Locale configuration for multi-language support.
     * Used for displayName, description, and other localizable strings.
     *
     * @example
     * locale: {
     *   locales: ['en', 'ja', 'vi'],
     *   defaultLocale: 'en',
     *   fallbackLocale: 'en'
     * }
     */
    readonly locale?: LocaleConfig;
}
/**
 * Resolved configuration with all defaults applied.
 * locale is optional since multi-language support is opt-in.
 * additionalSchemaPaths is optional since it's not required.
 */
interface ResolvedOmnifyConfig extends Required<Omit<OmnifyConfig, 'plugins' | 'locale' | 'additionalSchemaPaths'>> {
    readonly plugins: readonly OmnifyPlugin[];
    readonly locale?: LocaleConfig;
    readonly additionalSchemaPaths?: readonly AdditionalSchemaPath[];
}

/**
 * Built-in property types supported by omnify-schema.
 * Custom types can be added via plugins.
 */
type BuiltInPropertyType = 'String' | 'TinyInt' | 'Int' | 'BigInt' | 'Float' | 'Decimal' | 'Boolean' | 'Text' | 'MediumText' | 'LongText' | 'Date' | 'Time' | 'Timestamp' | 'Json' | 'Email' | 'Password' | 'File' | 'Point' | 'Coordinates' | 'Enum' | 'EnumRef' | 'Association';
/**
 * Property type - can be a built-in type or a custom plugin type (string).
 */
type PropertyType = BuiltInPropertyType | (string & {});
/**
 * Relationship cardinality types for associations.
 */
type AssociationRelation = 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany' | 'MorphTo' | 'MorphOne' | 'MorphMany' | 'MorphToMany' | 'MorphedByMany';
/**
 * Referential action for foreign key constraints.
 */
type ReferentialAction = 'CASCADE' | 'SET NULL' | 'SET DEFAULT' | 'RESTRICT' | 'NO ACTION';
/**
 * Pivot field definition - simplified property for pivot tables.
 * Only supports basic types suitable for pivot tables.
 */
interface PivotFieldDefinition {
    /** Property type (String, Int, Boolean, Timestamp, Enum, etc.) */
    readonly type: Exclude<PropertyType, 'Association'>;
    /** Whether the field can be null */
    readonly nullable?: boolean;
    /** Default value for the field */
    readonly default?: unknown;
    /** String length (for String type) */
    readonly length?: number;
    /** Whether the field is unsigned (for numeric types) */
    readonly unsigned?: boolean;
    /**
     * Enum values (only for type: Enum).
     * Supports both simple strings and objects with value/label.
     * @example
     * ```yaml
     * # Simple enum values
     * enum: [owner, admin, member]
     *
     * # With labels/translations
     * enum:
     *   - value: owner
     *     label: { en: Owner, ja: オーナー }
     *   - value: admin
     *     label: { en: Administrator, ja: 管理者 }
     * ```
     */
    readonly enum?: readonly (string | InlineEnumValue)[];
    /** Display name for the field (supports multi-language) */
    readonly displayName?: LocalizedString;
}
/**
 * Association property definition - defines a relationship to another schema.
 */
interface AssociationDefinition {
    /** Display name for the association (supports multi-language) */
    readonly displayName?: LocalizedString;
    /** Must be 'Association' for association properties */
    readonly type: 'Association';
    /** Relationship cardinality */
    readonly relation: AssociationRelation;
    /** Target schema name (e.g., 'User', 'Product') - for standard relations */
    readonly target?: string;
    /** Target schema names for polymorphic relations (MorphTo) */
    readonly targets?: readonly string[];
    /** Polymorphic name for inverse side (MorphOne, MorphMany, MorphedByMany) */
    readonly morphName?: string;
    /** Property name on the target schema that maps back (for bidirectional) */
    readonly inversedBy?: string;
    /** Property name on this schema that is mapped by target (for bidirectional) */
    readonly mappedBy?: string;
    /** Action when referenced record is deleted */
    readonly onDelete?: ReferentialAction;
    /** Action when referenced record is updated */
    readonly onUpdate?: ReferentialAction;
    /** Whether this side owns the relationship (has the foreign key) */
    readonly owning?: boolean;
    /** Custom join table name for ManyToMany or MorphToMany */
    readonly joinTable?: string;
    /** Additional fields on the pivot table (for ManyToMany, MorphToMany) */
    readonly pivotFields?: Readonly<Record<string, PivotFieldDefinition>>;
}
/**
 * Validation rules for a property.
 * These are for application-level validation ONLY, NOT database structure.
 * Database structure is controlled by: nullable, length, unique, etc.
 *
 * Maps to Laravel validation rules and Zod schemas.
 */
interface ValidationRules {
    /**
     * Whether the field is required (validation only).
     * This does NOT affect database nullable - use 'nullable' for database.
     * Laravel: required | Zod: (no .optional())
     */
    readonly required?: boolean;
    /**
     * Minimum length validation (for String types).
     * Laravel: min:n | Zod: .min(n)
     */
    readonly minLength?: number;
    /**
     * Maximum length validation (for String types).
     * Must be <= property 'length' (database column size).
     * Laravel: max:n | Zod: .max(n)
     */
    readonly maxLength?: number;
    /**
     * Must be a valid URL.
     * Laravel: url | Zod: z.url()
     */
    readonly url?: boolean;
    /**
     * Must be a valid UUID.
     * Laravel: uuid | Zod: z.uuid()
     */
    readonly uuid?: boolean;
    /**
     * Must be a valid IP address (v4 or v6).
     * Laravel: ip | Zod: z.ip()
     */
    readonly ip?: boolean;
    /**
     * Must be a valid IPv4 address.
     * Laravel: ipv4 | Zod: z.ipv4()
     */
    readonly ipv4?: boolean;
    /**
     * Must be a valid IPv6 address.
     * Laravel: ipv6 | Zod: z.ipv6()
     */
    readonly ipv6?: boolean;
    /**
     * Only alphabetic characters (a-z, A-Z).
     * Laravel: alpha | Zod: .regex(/^[a-zA-Z]+$/)
     */
    readonly alpha?: boolean;
    /**
     * Only alphanumeric characters (a-z, A-Z, 0-9).
     * Laravel: alpha_num | Zod: .regex(/^[a-zA-Z0-9]+$/)
     */
    readonly alphaNum?: boolean;
    /**
     * Only alphanumeric, dash, and underscore (a-z, A-Z, 0-9, -, _).
     * Laravel: alpha_dash | Zod: .regex(/^[a-zA-Z0-9_-]+$/)
     */
    readonly alphaDash?: boolean;
    /**
     * Only numeric characters (0-9).
     * Laravel: numeric | Zod: .regex(/^\d+$/)
     */
    readonly numeric?: boolean;
    /**
     * Must be exactly n digits.
     * Laravel: digits:n | Zod: .length(n).regex(/^\d+$/)
     */
    readonly digits?: number;
    /**
     * Must be between min and max digits.
     * Laravel: digits_between:min,max | Zod: .min(min).max(max).regex(/^\d+$/)
     */
    readonly digitsBetween?: readonly [number, number];
    /**
     * Must start with one of the given prefixes.
     * Laravel: starts_with:a,b | Zod: .startsWith(prefix)
     */
    readonly startsWith?: string | readonly string[];
    /**
     * Must end with one of the given suffixes.
     * Laravel: ends_with:a,b | Zod: .endsWith(suffix)
     */
    readonly endsWith?: string | readonly string[];
    /**
     * Must be entirely lowercase.
     * Laravel: lowercase | Zod: .refine(v => v === v.toLowerCase())
     */
    readonly lowercase?: boolean;
    /**
     * Must be entirely uppercase.
     * Laravel: uppercase | Zod: .refine(v => v === v.toUpperCase())
     */
    readonly uppercase?: boolean;
    /**
     * Minimum value (inclusive).
     * Laravel: min:n | Zod: .gte(n)
     */
    readonly min?: number;
    /**
     * Maximum value (inclusive).
     * Laravel: max:n | Zod: .lte(n)
     */
    readonly max?: number;
    /**
     * Must be between min and max (inclusive).
     * Laravel: between:min,max | Zod: .gte(min).lte(max)
     */
    readonly between?: readonly [number, number];
    /**
     * Must be greater than value.
     * Laravel: gt:n | Zod: .gt(n)
     */
    readonly gt?: number;
    /**
     * Must be less than value.
     * Laravel: lt:n | Zod: .lt(n)
     */
    readonly lt?: number;
    /**
     * Must be a multiple of value.
     * Laravel: multiple_of:n | Zod: .multipleOf(n)
     */
    readonly multipleOf?: number;
    /**
     * Minimum array items.
     * Laravel: array|min:n | Zod: z.array().min(n)
     */
    readonly arrayMin?: number;
    /**
     * Maximum array items.
     * Laravel: array|max:n | Zod: z.array().max(n)
     */
    readonly arrayMax?: number;
}
/**
 * Base property definition shared by all property types.
 */
interface BasePropertyDefinition {
    /** Property type (String, Int, Association, etc.) */
    readonly type: PropertyType;
    /** Human-readable display name (supports multi-language) */
    readonly displayName?: LocalizedString;
    /** Whether the field can be null */
    readonly nullable?: boolean;
    /** Default value for the field */
    readonly default?: unknown;
    /** Whether this field must be unique */
    readonly unique?: boolean;
    /** Field description/comment (supports multi-language) */
    readonly description?: LocalizedString;
    /** Previous field name for rename migrations (remove after migration runs) */
    readonly renamedFrom?: string;
    /** Validation rules (application-level only, NOT database) */
    readonly rules?: ValidationRules;
    /**
     * Whether this field is the primary key.
     * Use with `id: false` in schema options to create tables with custom primary keys.
     *
     * @example
     * ```yaml
     * # Schema with custom string primary key (like Laravel's cache table)
     * Cache:
     *   options:
     *     id: false  # Disable auto-generated id column
     *     timestamps: false
     *   properties:
     *     key:
     *       type: String
     *       primary: true  # This becomes the primary key
     *     value:
     *       type: Text
     *     expiration:
     *       type: Int
     * ```
     */
    readonly primary?: boolean;
    /**
     * Whether this field should be hidden in API responses/serialization.
     * In Laravel, this adds the field to the $hidden array.
     * Password type is automatically hidden.
     */
    readonly hidden?: boolean;
    /**
     * Whether this field is mass assignable.
     * In Laravel, this controls the $fillable array.
     * @default true (all non-association fields are fillable by default)
     */
    readonly fillable?: boolean;
    /**
     * Placeholder text for form inputs (supports multi-language).
     * Used in frontend forms to show hint text before user input.
     *
     * @example
     * placeholder: "Enter your email"
     *
     * @example
     * placeholder:
     *   en: "Enter your email"
     *   ja: "メールアドレスを入力"
     *   vi: "Nhập email của bạn"
     */
    readonly placeholder?: LocalizedString;
    /**
     * Per-field settings for compound types.
     * Allows overriding nullable, hidden, fillable for specific expanded fields.
     * Field names should match the suffix defined in the compound type (e.g., 'LastName', 'FirstName').
     *
     * @example
     * fields:
     *   LastNameKana:
     *     nullable: true
     *   FirstNameKana:
     *     nullable: true
     *     hidden: true
     */
    readonly fields?: Readonly<Record<string, CompoundFieldOverride>>;
}
/**
 * Override settings for a specific expanded field in a compound type.
 */
interface CompoundFieldOverride {
    /** Override nullable for this field */
    readonly nullable?: boolean;
    /** Override hidden for this field */
    readonly hidden?: boolean;
    /** Override fillable for this field */
    readonly fillable?: boolean;
    /** Override length for string fields */
    readonly length?: number;
    /**
     * Override display name (label) for this field (supports multi-language).
     * If not specified, uses the default label from the plugin type definition.
     *
     * @example
     * fields:
     *   Lastname:
     *     displayName:
     *       en: "Last Name"
     *       ja: "姓"
     *       vi: "Họ"
     */
    readonly displayName?: LocalizedString;
    /**
     * Override placeholder for this field (supports multi-language).
     * If not specified, uses the default placeholder from the plugin type definition.
     *
     * @example
     * fields:
     *   Lastname:
     *     placeholder:
     *       en: "e.g. Yamada"
     *       ja: "例：山田"
     *       vi: "VD: Nguyễn"
     */
    readonly placeholder?: LocalizedString;
}
/**
 * String property with length constraint.
 */
interface StringPropertyDefinition extends BasePropertyDefinition {
    readonly type: 'String' | 'Email' | 'Password';
    /** Maximum character length */
    readonly length?: number;
}
/**
 * Numeric property definition.
 */
interface NumericPropertyDefinition extends BasePropertyDefinition {
    readonly type: 'TinyInt' | 'Int' | 'BigInt' | 'Float' | 'Decimal';
    /** Whether the number is unsigned (positive only) */
    readonly unsigned?: boolean;
    /** Total number of digits for Decimal (default: 8) */
    readonly precision?: number;
    /** Number of decimal places for Decimal (default: 2) */
    readonly scale?: number;
}
/**
 * Inline enum value with optional label and extra properties.
 */
interface InlineEnumValue {
    readonly value: string;
    /** Display label - supports multi-language (string or locale map) */
    readonly label?: LocalizedString;
    readonly extra?: Readonly<Record<string, string | number | boolean>>;
}
/**
 * Enum property definition - inline enum values.
 * Supports both simple strings and objects with value/label.
 */
interface EnumPropertyDefinition extends BasePropertyDefinition {
    readonly type: 'Enum';
    /** Inline enum values - can be strings or objects with value/label */
    readonly enum: readonly (string | InlineEnumValue)[];
}
/**
 * EnumRef property definition - reference to shared enum schema.
 */
interface EnumRefPropertyDefinition extends BasePropertyDefinition {
    readonly type: 'EnumRef';
    /** Name of the enum schema to reference */
    readonly enum: string;
}
/**
 * File property definition - polymorphic file attachment.
 * Creates morphOne/morphMany relationship to the files table.
 */
interface FilePropertyDefinition extends BasePropertyDefinition {
    readonly type: 'File';
    /** Allow multiple files (creates morphMany instead of morphOne) */
    readonly multiple?: boolean;
    /** Maximum number of files (only when multiple=true) */
    readonly maxFiles?: number;
    /** Accepted file extensions (e.g., ['jpg', 'png', 'pdf']) */
    readonly accept?: readonly string[];
    /** Maximum file size in KB */
    readonly maxSize?: number;
}
/**
 * Union type for all property definitions.
 */
type PropertyDefinition = (BasePropertyDefinition & {
    readonly type: PropertyType;
}) | StringPropertyDefinition | NumericPropertyDefinition | EnumPropertyDefinition | EnumRefPropertyDefinition | FilePropertyDefinition | AssociationDefinition;
/**
 * Index type for specialized indexes.
 */
type IndexType = 'btree' | 'hash' | 'fulltext' | 'spatial' | 'gin' | 'gist';
/**
 * Index definition for database optimization.
 */
interface IndexDefinition {
    /** Columns to include in the index */
    readonly columns: readonly string[];
    /** Whether this is a unique index */
    readonly unique?: boolean;
    /** Custom index name */
    readonly name?: string;
    /** Index type (btree, hash, fulltext, spatial, gin, gist) */
    readonly type?: IndexType;
}
/**
 * ID column type options.
 */
type IdType = 'BigInt' | 'Int' | 'Uuid' | 'String';
/**
 * Schema-level options for behavior configuration.
 */
interface SchemaOptions {
    /**
     * Whether to auto-generate an 'id' primary key column.
     * Set to false for pivot tables or tables with custom primary keys.
     * @default true
     */
    readonly id?: boolean;
    /**
     * Type of the auto-generated 'id' column.
     * Only applies when id is true (default).
     * @default 'BigInt'
     */
    readonly idType?: IdType;
    /** Add created_at and updated_at timestamp columns */
    readonly timestamps?: boolean;
    /** Add deleted_at column for soft deletes */
    readonly softDelete?: boolean;
    /** Columns that should be unique (simple unique constraints) */
    readonly unique?: readonly string[] | readonly (readonly string[])[];
    /** Database indexes for query optimization */
    readonly indexes?: readonly IndexDefinition[];
    /** Enable translations support */
    readonly translations?: boolean;
    /** Custom table name (defaults to pluralized snake_case of schema name) */
    readonly tableName?: string;
    /** Enable authenticatable trait (for User-like schemas) */
    readonly authenticatable?: boolean;
    /** Login ID field for authenticatable */
    readonly authenticatableLoginIdField?: string;
    /** Password field for authenticatable */
    readonly authenticatablePasswordField?: string;
    /** Guard name for authenticatable */
    readonly authenticatableGuardName?: string;
    /**
     * Hide this schema from model generation.
     * When true, migrations are still generated but models (Laravel/TypeScript) are not.
     * Useful for system tables like cache, jobs, sessions.
     * @default false
     */
    readonly hidden?: boolean;
}
/**
 * Schema kind - determines how the schema is processed.
 * - 'object': Regular schema that generates a database table
 * - 'enum': Enum schema that generates enum types
 * - 'partial': Partial schema that extends an existing schema
 * - 'pivot': Pivot table schema for ManyToMany relationships (generates table + model)
 */
type SchemaKind = 'object' | 'enum' | 'partial' | 'pivot';
/**
 * Complete schema definition representing a database entity.
 */
interface SchemaDefinition {
    /** Schema kind (defaults to 'object') */
    readonly kind?: SchemaKind;
    /**
     * Target schema name for partial schemas.
     * Only used when kind is 'partial'.
     * The properties will be merged into the target schema.
     * Target schema properties take priority over partial properties.
     */
    readonly target?: string;
    /**
     * Priority for partial schema merging (1-100).
     * Only used when kind is 'partial'.
     * Lower numbers are merged first (higher priority).
     * Default is 50. Use 1-49 for high priority, 51-100 for low priority.
     */
    readonly priority?: number;
    /**
     * Source schemas for pivot tables.
     * Only used when kind is 'pivot'.
     * Defines the two schemas that this pivot table connects.
     * @example
     * ```yaml
     * kind: pivot
     * pivotFor: [User, Role]  # Creates user_id and role_id columns
     * ```
     */
    readonly pivotFor?: readonly [string, string];
    /** Human-readable display name (supports multi-language) */
    readonly displayName?: LocalizedString;
    /** Property to use as the title/label for records */
    readonly titleIndex?: string;
    /** Schema group for organization */
    readonly group?: string;
    /** Schema-level options */
    readonly options?: SchemaOptions;
    /** Property definitions */
    readonly properties?: Readonly<Record<string, PropertyDefinition>>;
    /** Enum values (when kind is 'enum') */
    readonly values?: readonly string[];
}
/**
 * Loaded schema with additional metadata.
 */
interface LoadedSchema extends SchemaDefinition {
    /** Schema name (derived from file name) */
    readonly name: string;
    /** File path where the schema was loaded from */
    readonly filePath: string;
    /** Relative path within schemas directory */
    readonly relativePath: string;
    /**
     * Package output configuration for this schema.
     * Set when the schema is loaded from an additionalSchemaPath with output config.
     * Generators use this to route outputs to the package directory.
     */
    readonly packageOutput?: PackageOutputConfig;
}
/**
 * Collection of loaded schemas indexed by name.
 */
type SchemaCollection = Readonly<Record<string, LoadedSchema>>;

/**
 * @famgia/omnify-types - Error Types
 *
 * Type definitions for omnify error handling.
 * Errors follow the format: file:line + message + suggestion
 */
/**
 * Error code categories:
 * - E0xx: Configuration errors
 * - E1xx: Schema parsing errors
 * - E2xx: Schema validation errors
 * - E3xx: Plugin errors
 * - E4xx: Atlas/Database errors
 * - E5xx: Generation errors
 * - E9xx: Internal errors
 */
type ErrorCode = 'E001' | 'E002' | 'E003' | 'E004' | 'E005' | 'E101' | 'E102' | 'E103' | 'E104' | 'E105' | 'E201' | 'E202' | 'E203' | 'E204' | 'E205' | 'E206' | 'E207' | 'E208' | 'E301' | 'E302' | 'E303' | 'E304' | 'E305' | 'E401' | 'E402' | 'E403' | 'E404' | 'E405' | 'E406' | 'E407' | 'E408' | 'E501' | 'E502' | 'E503' | 'E504' | 'E901' | 'E902';
/**
 * Source location where an error occurred.
 */
interface ErrorLocation {
    /** File path where the error occurred */
    readonly file?: string;
    /** Line number (1-based) */
    readonly line?: number;
    /** Column number (1-based) */
    readonly column?: number;
}
/**
 * Structured error information for omnify errors.
 */
interface OmnifyErrorInfo {
    /** Error code (e.g., 'E201') */
    readonly code: ErrorCode;
    /** Human-readable error message */
    readonly message: string;
    /** Location where the error occurred */
    readonly location?: ErrorLocation;
    /** Suggested fix for the error */
    readonly suggestion?: string;
    /** Additional context or details */
    readonly details?: Record<string, unknown>;
    /** Original error if this wraps another error */
    readonly cause?: Error;
}
/**
 * Result type for operations that may fail.
 */
type Result<T, E = OmnifyErrorInfo> = {
    readonly ok: true;
    readonly value: T;
} | {
    readonly ok: false;
    readonly error: E;
};
/**
 * Helper to create a successful result.
 */
declare function ok<T>(value: T): Result<T, never>;
/**
 * Helper to create an error result.
 */
declare function err<E>(error: E): Result<never, E>;

export { type AdditionalSchemaPath, type AssociationDefinition, type AssociationRelation, type BasePropertyDefinition, type BuiltInPropertyType, type ColumnChange, type CompoundFieldOverride, type CompoundTypeAccessor, type CustomTypeDefinition, DEFAULT_LOCALE_CONFIG, type DatabaseConfig, type DatabaseDriver, type EnumPropertyDefinition, type EnumRefPropertyDefinition, type ErrorCode, type ErrorLocation, type ExpandedFieldDefinition, type FieldValidationRules, type FilePropertyDefinition, type GeneratorContext, type GeneratorDefinition, type GeneratorOutput, type GeneratorOutputType, type IdType, type IndexChange, type IndexDefinition, type IndexSnapshot, type IndexType, type InlineEnumValue, type LaravelOutputConfig, type LoadedSchema, type LocaleCode, type LocaleConfig, type LocaleMap, type LocaleResolutionOptions, type LocalizedString, type NumericPropertyDefinition, type OmnifyConfig, type OmnifyErrorInfo, type OmnifyPlugin, type OutputConfig, type PackageLaravelOutputConfig, type PackageOutputConfig, type PivotFieldDefinition, type PluginConfigField, type PluginConfigFieldType, type PluginConfigSchema, type PluginConfigSelectOption, type PluginContext, type PluginEnumDefinition, type PluginEnumValue, type PluginFactory, type PluginLogger, type PropertyDefinition, type PropertySnapshot, type PropertyType, type ReferentialAction, type ResolvedOmnifyConfig, type Result, type SchemaChange, type SchemaChangeType, type SchemaCollection, type SchemaDefinition, type SchemaKind, type SchemaOptions, type SqlColumnDefinition, type StringPropertyDefinition, type TypeScriptOutputConfig, type TypeScriptTypeInfo, type ValidationMessages, type ValidationRules, err, getAvailableLocales, isLocaleMap, isLocalizedString, mergeLocalizedStrings, ok, resolveLocalizedString, toLocaleMap };
