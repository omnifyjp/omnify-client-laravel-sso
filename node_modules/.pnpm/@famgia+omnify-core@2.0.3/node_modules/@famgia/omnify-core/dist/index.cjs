"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  FILE_SCHEMA_NAME: () => FILE_SCHEMA_NAME,
  Omnify: () => Omnify,
  OmnifyError: () => OmnifyError,
  PluginManager: () => PluginManager,
  VersionStore: () => VersionStore,
  allAdapters: () => allAdapters,
  antigravityAdapter: () => antigravityAdapter,
  atlasError: () => atlasError,
  atlasNotFoundError: () => atlasNotFoundError,
  circularReferenceError: () => circularReferenceError,
  claudeAdapter: () => claudeAdapter,
  configError: () => configError,
  configNotFoundError: () => configNotFoundError,
  createFileLoadedSchema: () => createFileLoadedSchema,
  createFileSchemaDefinition: () => createFileSchemaDefinition,
  createOmnify: () => createOmnify,
  createPluginManager: () => createPluginManager,
  createVersionStore: () => createVersionStore,
  cursorAdapter: () => cursorAdapter,
  duplicateSchemaError: () => duplicateSchemaError,
  ensureFileSchema: () => ensureFileSchema,
  err: () => import_omnify_types3.err,
  expandProperty: () => expandProperty,
  expandSchema: () => expandSchema,
  expandSchemaProperties: () => expandSchemaProperties,
  expandSchemas: () => expandSchemas,
  fileNameToSchemaName: () => fileNameToSchemaName,
  findReferencedSchemas: () => findReferencedSchemas,
  findReferencingSchemas: () => findReferencingSchemas,
  formatError: () => formatError,
  formatErrorPlain: () => formatErrorPlain,
  formatErrorSummary: () => formatErrorSummary,
  generateAIGuides: () => generateAIGuides,
  generateFileSchemaYaml: () => generateFileSchemaYaml,
  generationError: () => generationError,
  getAdapter: () => getAdapter,
  getAdapters: () => getAdapters,
  getAssociationMetadata: () => getAssociationMetadata,
  getAvailableAdapters: () => getAvailableAdapters,
  getCustomTypeNames: () => getCustomTypeNames,
  getEntitySchemas: () => getEntitySchemas,
  getEnumSchemas: () => getEnumSchemas,
  getExitCode: () => getExitCode,
  getGroups: () => getGroups,
  getPropertyMetadata: () => getPropertyMetadata,
  getRelationshipGraph: () => getRelationshipGraph,
  getSchemaMetadata: () => getSchemaMetadata,
  getSchemaNames: () => getSchemaNames,
  getSchemasByGroup: () => getSchemasByGroup,
  getSchemasByKind: () => getSchemasByKind,
  getTopologicalOrder: () => getTopologicalOrder,
  getTypeInfo: () => getTypeInfo,
  hasCircularReferences: () => hasCircularReferences,
  internalError: () => internalError,
  introspectSchema: () => introspectSchema,
  introspectSchemas: () => introspectSchemas,
  invalidAssociationTargetError: () => invalidAssociationTargetError,
  invalidConfigError: () => invalidConfigError,
  invalidPropertyTypeError: () => invalidPropertyTypeError,
  isCompoundType: () => isCompoundType,
  jsonSyntaxError: () => jsonSyntaxError,
  loadSchema: () => loadSchema,
  loadSchemas: () => loadSchemas,
  mergePartialSchemas: () => mergePartialSchemas,
  missingConfigFieldError: () => missingConfigFieldError,
  missingFieldError: () => missingFieldError,
  notImplementedError: () => notImplementedError,
  ok: () => import_omnify_types3.ok,
  outputWriteError: () => outputWriteError,
  parseJsonSchema: () => parseJsonSchema,
  parseYamlSchema: () => parseYamlSchema,
  pluginError: () => pluginError,
  pluginNotFoundError: () => pluginNotFoundError,
  pluginTypeConflictError: () => pluginTypeConflictError,
  schemaNotFoundError: () => schemaNotFoundError,
  schemaParseError: () => schemaParseError,
  schemasHaveFileProperties: () => schemasHaveFileProperties,
  shouldGenerateAIGuides: () => shouldGenerateAIGuides,
  validateAssociations: () => validateAssociations,
  validateDefaultValue: () => validateDefaultValue,
  validateEnumSchema: () => validateEnumSchema,
  validateOptions: () => validateOptions,
  validateProperties: () => validateProperties,
  validatePropertyType: () => validatePropertyType,
  validateSchema: () => validateSchema,
  validateSchemas: () => validateSchemas,
  validationError: () => validationError,
  yamlSyntaxError: () => yamlSyntaxError
});
module.exports = __toCommonJS(index_exports);
var import_omnify_types3 = require("@famgia/omnify-types");

// src/errors/omnify-error.ts
var OmnifyError = class _OmnifyError extends Error {
  /** Error code (e.g., 'E201') */
  code;
  /** Source location where the error occurred */
  location;
  /** Suggested fix for the error */
  suggestion;
  /** Additional context or details */
  details;
  /** Original error if this wraps another error */
  cause;
  constructor(message, code, location, suggestion, options) {
    super(message);
    this.name = "OmnifyError";
    this.code = code;
    if (location !== void 0) {
      this.location = location;
    }
    if (suggestion !== void 0) {
      this.suggestion = suggestion;
    }
    if (options?.details !== void 0) {
      this.details = options.details;
    }
    if (options?.cause !== void 0) {
      this.cause = options.cause;
    }
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _OmnifyError);
    }
  }
  /**
   * Creates an OmnifyError from an OmnifyErrorInfo object.
   */
  static fromInfo(info) {
    const options = {};
    if (info.details !== void 0) {
      options.details = info.details;
    }
    if (info.cause !== void 0) {
      options.cause = info.cause;
    }
    return new _OmnifyError(
      info.message,
      info.code,
      info.location,
      info.suggestion,
      Object.keys(options).length > 0 ? options : void 0
    );
  }
  /**
   * Wraps an unknown error as an OmnifyError.
   * Useful for catching and re-throwing with context.
   */
  static wrap(error, code = "E901", location) {
    if (error instanceof _OmnifyError) {
      return error;
    }
    const message = error instanceof Error ? error.message : String(error);
    if (error instanceof Error) {
      return new _OmnifyError(message, code, location, void 0, { cause: error });
    }
    return new _OmnifyError(message, code, location);
  }
  /**
   * Converts to OmnifyErrorInfo for serialization.
   */
  toInfo() {
    const info = {
      code: this.code,
      message: this.message
    };
    if (this.location !== void 0) {
      info.location = this.location;
    }
    if (this.suggestion !== void 0) {
      info.suggestion = this.suggestion;
    }
    if (this.details !== void 0) {
      info.details = this.details;
    }
    if (this.cause !== void 0) {
      info.cause = this.cause;
    }
    return info;
  }
  /**
   * Returns a formatted string representation.
   * Format: "Error [CODE]: message\n  --> file:line:column"
   */
  toString() {
    const parts = [];
    parts.push(`Error [${this.code}]: ${this.message}`);
    if (this.location?.file) {
      const loc = this.location;
      let locationStr = `  --> ${loc.file}`;
      if (loc.line !== void 0) {
        locationStr += `:${loc.line}`;
        if (loc.column !== void 0) {
          locationStr += `:${loc.column}`;
        }
      }
      parts.push(locationStr);
    }
    if (this.suggestion) {
      parts.push(`  Suggestion: ${this.suggestion}`);
    }
    return parts.join("\n");
  }
  /**
   * Returns the file path from location, if available.
   */
  get file() {
    return this.location?.file;
  }
  /**
   * Returns the line number from location, if available.
   */
  get line() {
    return this.location?.line;
  }
  /**
   * Returns the column number from location, if available.
   */
  get column() {
    return this.location?.column;
  }
};

// src/errors/formatter.ts
var colors = {
  reset: "\x1B[0m",
  bold: "\x1B[1m",
  dim: "\x1B[2m",
  red: "\x1B[31m",
  yellow: "\x1B[33m",
  blue: "\x1B[34m",
  cyan: "\x1B[36m",
  gray: "\x1B[90m"
};
function colorize(text, colorCode, enabled) {
  return enabled ? `${colorCode}${text}${colors.reset}` : text;
}
function formatError(error, options = {}) {
  const {
    color = true,
    showContext = true,
    contextLines = 2,
    sourceContent
  } = options;
  const lines = [];
  const errorLabel = colorize("error", colors.red + colors.bold, color);
  const code = colorize(`[${error.code}]`, colors.red, color);
  const message = colorize(error.message, colors.bold, color);
  lines.push(`${errorLabel}${code}: ${message}`);
  const locFile = error.location?.file;
  if (locFile !== void 0) {
    const loc = error.location;
    let locationStr = colorize("  --> ", colors.blue, color);
    locationStr += colorize(locFile, colors.cyan, color);
    if (loc?.line !== void 0) {
      locationStr += `:${loc.line}`;
      if (loc.column !== void 0) {
        locationStr += `:${loc.column}`;
      }
    }
    lines.push(locationStr);
  }
  if (showContext && sourceContent && error.location?.line !== void 0) {
    const contextOutput = formatSourceContext(
      sourceContent,
      error.location.line,
      error.location.column,
      error.suggestion,
      contextLines,
      color
    );
    lines.push(contextOutput);
  }
  if (error.suggestion && (!showContext || !sourceContent)) {
    const suggestionLabel = colorize("  = suggestion:", colors.cyan, color);
    lines.push(`${suggestionLabel} ${error.suggestion}`);
  }
  return lines.join("\n");
}
function formatSourceContext(source, errorLine, errorColumn, suggestion, contextCount, colorEnabled) {
  const sourceLines = source.split("\n");
  const startLine = Math.max(1, errorLine - contextCount);
  const endLine = Math.min(sourceLines.length, errorLine + contextCount);
  const gutterWidth = String(endLine).length;
  const output = [];
  output.push(colorize(`${" ".repeat(gutterWidth)} |`, colors.blue, colorEnabled));
  for (let i = startLine; i <= endLine; i++) {
    const lineContent = sourceLines[i - 1] ?? "";
    const lineNum = String(i).padStart(gutterWidth, " ");
    const gutter = colorize(`${lineNum} |`, colors.blue, colorEnabled);
    output.push(`${gutter} ${lineContent}`);
    if (i === errorLine && errorColumn !== void 0) {
      const underlineGutter = colorize(
        `${" ".repeat(gutterWidth)} |`,
        colors.blue,
        colorEnabled
      );
      const spaces = " ".repeat(errorColumn - 1);
      const underline = colorize("^", colors.red, colorEnabled);
      let underlineLine = `${underlineGutter} ${spaces}${underline}`;
      if (suggestion) {
        underlineLine += ` ${colorize(suggestion, colors.yellow, colorEnabled)}`;
      }
      output.push(underlineLine);
    }
  }
  output.push(colorize(`${" ".repeat(gutterWidth)} |`, colors.blue, colorEnabled));
  return output.join("\n");
}
function formatErrorSummary(errors, options = {}) {
  const { color = true } = options;
  if (errors.length === 0) {
    return "";
  }
  const formattedErrors = errors.map((e) => formatError(e, options));
  const summary = colorize(
    `
Found ${errors.length} error${errors.length === 1 ? "" : "s"}`,
    colors.red + colors.bold,
    color
  );
  return formattedErrors.join("\n\n") + summary;
}
function formatErrorPlain(error) {
  return formatError(error, { color: false, showContext: false });
}
function getExitCode(error) {
  const category = error.code.charAt(1);
  switch (category) {
    case "0":
      return 3;
    case "2":
      return 2;
    default:
      return 1;
  }
}

// src/errors/factories.ts
function buildLocation(file, line, column) {
  const loc = { file };
  if (line !== void 0) {
    loc.line = line;
  }
  if (column !== void 0) {
    loc.column = column;
  }
  return loc;
}
function buildOptions(cause) {
  return cause !== void 0 ? { cause } : void 0;
}
function configError(message, code = "E002", suggestion) {
  return new OmnifyError(message, code, void 0, suggestion);
}
function configNotFoundError(configPath) {
  return new OmnifyError(
    `Configuration file not found: ${configPath}`,
    "E001",
    { file: configPath },
    "Run `omnify init` to create a configuration file"
  );
}
function invalidConfigError(message, configPath) {
  return new OmnifyError(
    message,
    "E002",
    { file: configPath },
    "Check your omnify.config.ts for syntax errors"
  );
}
function missingConfigFieldError(field, configPath) {
  return new OmnifyError(
    `Missing required configuration field: ${field}`,
    "E003",
    { file: configPath },
    `Add '${field}' to your configuration file`
  );
}
function schemaParseError(message, location, suggestion) {
  return new OmnifyError(message, "E102", location, suggestion);
}
function schemaNotFoundError(schemaPath) {
  return new OmnifyError(
    `Schema file not found: ${schemaPath}`,
    "E101",
    { file: schemaPath },
    "Check that the file exists and the path is correct"
  );
}
function yamlSyntaxError(message, file, line, column) {
  return new OmnifyError(
    `Invalid YAML syntax: ${message}`,
    "E102",
    buildLocation(file, line, column),
    "Check for proper indentation and YAML syntax"
  );
}
function jsonSyntaxError(message, file, line, column) {
  return new OmnifyError(
    `Invalid JSON syntax: ${message}`,
    "E103",
    buildLocation(file, line, column),
    "Check for proper JSON syntax (quotes, commas, brackets)"
  );
}
function validationError(message, location, suggestion) {
  return new OmnifyError(message, "E202", location, suggestion);
}
function invalidPropertyTypeError(typeName, location, validTypes) {
  const suggestion = validTypes ? `Use one of: ${validTypes.slice(0, 5).join(", ")}${validTypes.length > 5 ? ", ..." : ""}` : void 0;
  return new OmnifyError(
    `Invalid property type '${typeName}'`,
    "E201",
    location,
    suggestion
  );
}
function missingFieldError(field, location) {
  return new OmnifyError(
    `Missing required field: ${field}`,
    "E202",
    location,
    `Add '${field}' to the schema definition`
  );
}
function invalidAssociationTargetError(target, location, availableSchemas) {
  const suggestion = availableSchemas ? `Available schemas: ${availableSchemas.slice(0, 5).join(", ")}${availableSchemas.length > 5 ? ", ..." : ""}` : "Check that the target schema exists";
  return new OmnifyError(
    `Invalid association target '${target}'`,
    "E203",
    location,
    suggestion
  );
}
function circularReferenceError(path2, location) {
  return new OmnifyError(
    `Circular reference detected: ${path2.join(" -> ")}`,
    "E204",
    location,
    "Remove the circular dependency or use a unidirectional relationship"
  );
}
function duplicateSchemaError(name, location, existingLocation) {
  const suggestion = existingLocation?.file ? `Schema already defined in ${existingLocation.file}` : "Rename one of the schemas to avoid the conflict";
  return new OmnifyError(
    `Duplicate schema name '${name}'`,
    "E205",
    location,
    suggestion
  );
}
function pluginError(message, pluginName, cause) {
  return new OmnifyError(
    message,
    "E302",
    void 0,
    `Check the plugin '${pluginName}' for issues`,
    buildOptions(cause)
  );
}
function pluginNotFoundError(pluginName) {
  return new OmnifyError(
    `Plugin not found: ${pluginName}`,
    "E301",
    void 0,
    `Install the plugin with: npm install ${pluginName}`
  );
}
function pluginTypeConflictError(typeName, pluginA, pluginB) {
  return new OmnifyError(
    `Type '${typeName}' is defined by multiple plugins: ${pluginA}, ${pluginB}`,
    "E304",
    void 0,
    "Remove one of the conflicting plugins or rename the type"
  );
}
function atlasError(message, cause) {
  return new OmnifyError(
    message,
    "E402",
    void 0,
    "Check Atlas CLI output for details",
    buildOptions(cause)
  );
}
function atlasNotFoundError() {
  return new OmnifyError(
    "Atlas CLI not found",
    "E401",
    void 0,
    "Install Atlas CLI: https://atlasgo.io/getting-started"
  );
}
function generationError(message, outputPath, cause) {
  return new OmnifyError(
    message,
    "E501",
    outputPath ? { file: outputPath } : void 0,
    void 0,
    buildOptions(cause)
  );
}
function outputWriteError(outputPath, cause) {
  return new OmnifyError(
    `Failed to write output file: ${outputPath}`,
    "E503",
    { file: outputPath },
    "Check file permissions and disk space",
    buildOptions(cause)
  );
}
function internalError(message, cause) {
  return new OmnifyError(
    message,
    "E901",
    void 0,
    "This is a bug. Please report it at https://github.com/omnify/omnify-schema/issues",
    buildOptions(cause)
  );
}
function notImplementedError(feature) {
  return new OmnifyError(
    `Feature not implemented: ${feature}`,
    "E902",
    void 0,
    "This feature is planned for a future release"
  );
}

// src/schema/loader.ts
var fs = __toESM(require("fs/promises"), 1);
var path = __toESM(require("path"), 1);
var import_js_yaml = __toESM(require("js-yaml"), 1);
var import_omnify_types = require("@famgia/omnify-types");
function fileNameToSchemaName(fileName) {
  const baseName = path.basename(fileName, path.extname(fileName));
  if (!baseName.includes("-") && !baseName.includes("_")) {
    return baseName.charAt(0).toUpperCase() + baseName.slice(1);
  }
  return baseName.split(/[-_]/).map((part) => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase()).join("");
}
function parseYamlSchema(content, filePath) {
  try {
    const parsed = import_js_yaml.default.load(content);
    if (parsed === null || typeof parsed !== "object") {
      throw yamlSyntaxError("Schema must be a YAML object", filePath);
    }
    return buildSchemaDefinition(parsed);
  } catch (error) {
    if (error instanceof import_js_yaml.default.YAMLException) {
      const line = error.mark?.line !== void 0 ? error.mark.line + 1 : void 0;
      const column = error.mark?.column !== void 0 ? error.mark.column + 1 : void 0;
      throw yamlSyntaxError(error.reason || error.message, filePath, line, column);
    }
    throw error;
  }
}
function parseJsonSchema(content, filePath) {
  try {
    const parsed = JSON.parse(content);
    if (parsed === null || typeof parsed !== "object") {
      throw jsonSyntaxError("Schema must be a JSON object", filePath);
    }
    return buildSchemaDefinition(parsed);
  } catch (error) {
    if (error instanceof SyntaxError) {
      const match = error.message.match(/position (\d+)/);
      const positionStr = match?.[1];
      const position = positionStr !== void 0 ? parseInt(positionStr, 10) : void 0;
      let line;
      let column;
      if (position !== void 0) {
        const beforeError = content.substring(0, position);
        const lines = beforeError.split("\n");
        line = lines.length;
        const lastLine = lines[lines.length - 1];
        column = (lastLine !== void 0 ? lastLine.length : 0) + 1;
      }
      throw jsonSyntaxError(error.message, filePath, line, column);
    }
    throw error;
  }
}
var VALID_SCHEMA_FIELDS = /* @__PURE__ */ new Set([
  "kind",
  "target",
  // For partial schemas
  "priority",
  // For partial schemas (merge order)
  "pivotFor",
  // For pivot schemas (two schema names)
  "displayName",
  "titleIndex",
  "group",
  "options",
  "properties",
  "values"
]);
var VALID_SCHEMA_OPTIONS_FIELDS = /* @__PURE__ */ new Set([
  "id",
  "idType",
  "timestamps",
  "softDelete",
  "unique",
  "indexes",
  "translations",
  "tableName",
  "hidden",
  "authenticatable",
  "authenticatableLoginIdField",
  "authenticatablePasswordField",
  "authenticatableGuardName"
]);
function buildSchemaDefinition(data) {
  const schema = {};
  const unknownFields = [];
  for (const key of Object.keys(data)) {
    if (!VALID_SCHEMA_FIELDS.has(key)) {
      unknownFields.push(key);
    }
  }
  if (unknownFields.length > 0) {
    schema._unknownFields = unknownFields;
  }
  if (data.kind !== void 0) {
    schema.kind = data.kind;
  }
  if (data.target !== void 0 && typeof data.target === "string") {
    schema.target = data.target;
  }
  if (data.priority !== void 0 && typeof data.priority === "number") {
    schema.priority = data.priority;
  }
  if (data.pivotFor !== void 0 && Array.isArray(data.pivotFor) && data.pivotFor.length === 2) {
    schema.pivotFor = data.pivotFor;
  }
  if (data.displayName !== void 0 && (0, import_omnify_types.isLocalizedString)(data.displayName)) {
    schema.displayName = data.displayName;
  }
  if (data.titleIndex !== void 0 && typeof data.titleIndex === "string") {
    schema.titleIndex = data.titleIndex;
  }
  if (data.group !== void 0 && typeof data.group === "string") {
    schema.group = data.group;
  }
  if (data.options !== void 0 && typeof data.options === "object") {
    const optionsData = data.options;
    const unknownOptionsFields = [];
    for (const key of Object.keys(optionsData)) {
      if (!VALID_SCHEMA_OPTIONS_FIELDS.has(key)) {
        unknownOptionsFields.push(key);
      }
    }
    if (unknownOptionsFields.length > 0) {
      schema._unknownOptionsFields = unknownOptionsFields;
    }
    const options = buildSchemaOptions(optionsData);
    if (Object.keys(options).length > 0) {
      schema.options = options;
    }
  }
  if (data.properties !== void 0 && typeof data.properties === "object") {
    const { properties, invalidProperties } = buildProperties(data.properties);
    if (Object.keys(properties).length > 0) {
      schema.properties = properties;
    }
    if (invalidProperties.length > 0) {
      schema._invalidProperties = invalidProperties;
    }
  }
  if (data.values !== void 0 && Array.isArray(data.values)) {
    schema.values = data.values;
  }
  return schema;
}
function buildSchemaOptions(data) {
  const options = {};
  if (data.timestamps !== void 0 && typeof data.timestamps === "boolean") {
    options.timestamps = data.timestamps;
  }
  if (data.softDelete !== void 0 && typeof data.softDelete === "boolean") {
    options.softDelete = data.softDelete;
  }
  if (data.unique !== void 0) {
    options.unique = data.unique;
  }
  if (data.indexes !== void 0 && Array.isArray(data.indexes)) {
    options.indexes = data.indexes;
  }
  if (data.translations !== void 0 && typeof data.translations === "boolean") {
    options.translations = data.translations;
  }
  if (data.tableName !== void 0 && typeof data.tableName === "string") {
    options.tableName = data.tableName;
  }
  if (data.id !== void 0 && typeof data.id === "boolean") {
    options.id = data.id;
  }
  if (data.idType !== void 0) {
    options.idType = data.idType;
  }
  if (data.authenticatable !== void 0 && typeof data.authenticatable === "boolean") {
    options.authenticatable = data.authenticatable;
  }
  if (data.authenticatableLoginIdField !== void 0 && typeof data.authenticatableLoginIdField === "string") {
    options.authenticatableLoginIdField = data.authenticatableLoginIdField;
  }
  if (data.authenticatablePasswordField !== void 0 && typeof data.authenticatablePasswordField === "string") {
    options.authenticatablePasswordField = data.authenticatablePasswordField;
  }
  if (data.authenticatableGuardName !== void 0 && typeof data.authenticatableGuardName === "string") {
    options.authenticatableGuardName = data.authenticatableGuardName;
  }
  if (data.hidden !== void 0 && typeof data.hidden === "boolean") {
    options.hidden = data.hidden;
  }
  return options;
}
function buildProperties(data) {
  const properties = {};
  const invalidProperties = [];
  for (const [name, value] of Object.entries(data)) {
    if (value === void 0 || value === null) {
      continue;
    }
    if (typeof value === "object") {
      properties[name] = buildPropertyDefinition(value);
    } else {
      invalidProperties.push({
        propertyName: name,
        value,
        expectedFormat: `Property '${name}' must be an object with 'type' field. Example:
  ${name}:
    type: String
    nullable: true`
      });
    }
  }
  return { properties, invalidProperties };
}
var VALID_PROPERTY_FIELDS = /* @__PURE__ */ new Set([
  "type",
  "displayName",
  "nullable",
  "default",
  "unique",
  "primary",
  "description",
  "renamedFrom",
  // Placeholder for form inputs (multi-language)
  "placeholder",
  // String properties
  "length",
  // Numeric properties
  "unsigned",
  "precision",
  "scale",
  // Enum properties
  "enum",
  // Association properties
  "relation",
  "target",
  "targets",
  "morphName",
  "inversedBy",
  "mappedBy",
  "onDelete",
  "onUpdate",
  "owning",
  "joinTable",
  "pivotFields",
  // File properties
  "multiple",
  "maxFiles",
  "accept",
  "maxSize",
  // Validation rules (application-level only)
  "rules",
  // Laravel-specific properties
  "hidden",
  "fillable",
  // Per-field settings for compound types
  "fields",
  // Timestamp-specific properties
  "useCurrent",
  "useCurrentOnUpdate"
]);
function buildPropertyDefinition(data) {
  const prop = {
    type: data.type || "String"
  };
  const unknownFields = [];
  for (const key of Object.keys(data)) {
    if (!VALID_PROPERTY_FIELDS.has(key)) {
      unknownFields.push(key);
    }
  }
  if (unknownFields.length > 0) {
    prop._unknownFields = unknownFields;
  }
  if (data.displayName !== void 0 && (0, import_omnify_types.isLocalizedString)(data.displayName)) {
    prop.displayName = data.displayName;
  }
  if (data.nullable !== void 0 && typeof data.nullable === "boolean") {
    prop.nullable = data.nullable;
  }
  if (data.default !== void 0) {
    prop.default = data.default;
  }
  if (data.unique !== void 0 && typeof data.unique === "boolean") {
    prop.unique = data.unique;
  }
  if (data.primary !== void 0 && typeof data.primary === "boolean") {
    prop.primary = data.primary;
  }
  if (data.description !== void 0 && (0, import_omnify_types.isLocalizedString)(data.description)) {
    prop.description = data.description;
  }
  if (data.placeholder !== void 0 && (0, import_omnify_types.isLocalizedString)(data.placeholder)) {
    prop.placeholder = data.placeholder;
  }
  if (data.renamedFrom !== void 0 && typeof data.renamedFrom === "string") {
    prop.renamedFrom = data.renamedFrom;
  }
  if (data.length !== void 0 && typeof data.length === "number") {
    prop.length = data.length;
  }
  if (data.unsigned !== void 0 && typeof data.unsigned === "boolean") {
    prop.unsigned = data.unsigned;
  }
  if (data.precision !== void 0 && typeof data.precision === "number") {
    prop.precision = data.precision;
  }
  if (data.scale !== void 0 && typeof data.scale === "number") {
    prop.scale = data.scale;
  }
  if (data.enum !== void 0) {
    prop.enum = data.enum;
  }
  if (data.relation !== void 0 && typeof data.relation === "string") {
    prop.relation = data.relation;
  }
  if (data.target !== void 0 && typeof data.target === "string") {
    prop.target = data.target;
  }
  if (data.inversedBy !== void 0 && typeof data.inversedBy === "string") {
    prop.inversedBy = data.inversedBy;
  }
  if (data.mappedBy !== void 0 && typeof data.mappedBy === "string") {
    prop.mappedBy = data.mappedBy;
  }
  if (data.onDelete !== void 0 && typeof data.onDelete === "string") {
    prop.onDelete = data.onDelete;
  }
  if (data.onUpdate !== void 0 && typeof data.onUpdate === "string") {
    prop.onUpdate = data.onUpdate;
  }
  if (data.owning !== void 0 && typeof data.owning === "boolean") {
    prop.owning = data.owning;
  }
  if (data.joinTable !== void 0 && typeof data.joinTable === "string") {
    prop.joinTable = data.joinTable;
  }
  if (data.targets !== void 0 && Array.isArray(data.targets)) {
    prop.targets = data.targets;
  }
  if (data.morphName !== void 0 && typeof data.morphName === "string") {
    prop.morphName = data.morphName;
  }
  if (data.pivotFields !== void 0 && typeof data.pivotFields === "object") {
    prop.pivotFields = data.pivotFields;
  }
  if (data.multiple !== void 0 && typeof data.multiple === "boolean") {
    prop.multiple = data.multiple;
  }
  if (data.maxFiles !== void 0 && typeof data.maxFiles === "number") {
    prop.maxFiles = data.maxFiles;
  }
  if (data.accept !== void 0 && Array.isArray(data.accept)) {
    prop.accept = data.accept;
  }
  if (data.maxSize !== void 0 && typeof data.maxSize === "number") {
    prop.maxSize = data.maxSize;
  }
  if (data.rules !== void 0 && typeof data.rules === "object") {
    prop.rules = data.rules;
  }
  if (data.hidden !== void 0 && typeof data.hidden === "boolean") {
    prop.hidden = data.hidden;
  }
  if (data.fillable !== void 0 && typeof data.fillable === "boolean") {
    prop.fillable = data.fillable;
  }
  if (data.useCurrent !== void 0 && typeof data.useCurrent === "boolean") {
    prop.useCurrent = data.useCurrent;
  }
  if (data.useCurrentOnUpdate !== void 0 && typeof data.useCurrentOnUpdate === "boolean") {
    prop.useCurrentOnUpdate = data.useCurrentOnUpdate;
  }
  if (data.fields !== void 0 && typeof data.fields === "object" && data.fields !== null) {
    prop.fields = data.fields;
  }
  return prop;
}
async function loadSchema(filePath, options = {}) {
  const absolutePath = path.resolve(filePath);
  const baseDir = options.baseDir ? path.resolve(options.baseDir) : path.dirname(absolutePath);
  try {
    await fs.access(absolutePath);
  } catch {
    throw schemaNotFoundError(filePath);
  }
  const content = await fs.readFile(absolutePath, "utf-8");
  const ext = path.extname(absolutePath).toLowerCase();
  const schemaDefinition = ext === ".json" ? parseJsonSchema(content, filePath) : parseYamlSchema(content, filePath);
  const name = fileNameToSchemaName(absolutePath);
  const relativePath = path.relative(baseDir, absolutePath);
  const loadedSchema = {
    ...schemaDefinition,
    name,
    filePath: absolutePath,
    relativePath
  };
  return loadedSchema;
}
async function findSchemaFiles(dirPath, extensions, recursive) {
  const files = [];
  const entries = await fs.readdir(dirPath, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    if (entry.isDirectory() && recursive) {
      const subFiles = await findSchemaFiles(fullPath, extensions, recursive);
      files.push(...subFiles);
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name).toLowerCase();
      if (extensions.includes(ext)) {
        files.push(fullPath);
      }
    }
  }
  return files;
}
async function loadSchemas(directoryPath, options = {}) {
  const {
    extensions = [".yaml", ".yml", ".json"],
    recursive = true,
    skipPartialResolution = false
  } = options;
  const absoluteDir = path.resolve(directoryPath);
  try {
    const stat2 = await fs.stat(absoluteDir);
    if (!stat2.isDirectory()) {
      throw schemaNotFoundError(directoryPath);
    }
  } catch (error) {
    if (error.code === "ENOENT") {
      throw schemaNotFoundError(directoryPath);
    }
    throw error;
  }
  const schemaFiles = await findSchemaFiles(absoluteDir, extensions, recursive);
  const schemas = {};
  const partialSchemas = [];
  const schemaLocations = {};
  for (const filePath of schemaFiles) {
    const schema = await loadSchema(filePath, { baseDir: absoluteDir });
    if (schema.kind === "partial") {
      partialSchemas.push(schema);
      continue;
    }
    const existingLocation = schemaLocations[schema.name];
    if (existingLocation !== void 0) {
      throw duplicateSchemaError(
        schema.name,
        { file: filePath },
        { file: existingLocation }
      );
    }
    schemas[schema.name] = schema;
    schemaLocations[schema.name] = filePath;
  }
  if (skipPartialResolution) {
    for (const partial of partialSchemas) {
      const partialKey = `__partial__${partial.name}`;
      schemas[partialKey] = partial;
    }
    return schemas;
  }
  return mergePartialSchemas(schemas, partialSchemas);
}
function mergePartialSchemas(schemas, partials) {
  const partialSchemas = partials ?? [];
  const cleanSchemas = {};
  for (const [key, schema] of Object.entries(schemas)) {
    if (key.startsWith("__partial__")) {
      partialSchemas.push(schema);
    } else {
      cleanSchemas[key] = schema;
    }
  }
  partialSchemas.sort((a, b) => {
    const priorityA = a.priority ?? 50;
    const priorityB = b.priority ?? 50;
    return priorityA - priorityB;
  });
  for (const partial of partialSchemas) {
    const targetName = partial.name;
    const target = cleanSchemas[targetName];
    if (!target) {
      cleanSchemas[targetName] = {
        ...partial,
        name: targetName,
        // Use target name, not partial's filename-derived name
        kind: "object"
      };
      continue;
    }
    const mergedProperties = {
      ...partial.properties ?? {},
      ...target.properties ?? {}
    };
    cleanSchemas[targetName] = {
      ...target,
      properties: mergedProperties
    };
  }
  return cleanSchemas;
}
var FILE_SCHEMA_NAME = "File";
function schemasHaveFileProperties(schemas) {
  for (const schema of Object.values(schemas)) {
    if (!schema.properties) continue;
    for (const prop of Object.values(schema.properties)) {
      if (prop.type === "File") {
        return true;
      }
    }
  }
  return false;
}
function createFileSchemaDefinition() {
  return {
    displayName: "File",
    options: {
      timestamps: true,
      tableName: "files",
      indexes: [
        {
          columns: ["fileableType", "fileableId", "fileableField"],
          name: "files_fileable_index"
        }
      ]
    },
    properties: {
      path: {
        type: "String",
        displayName: "Storage Path"
      },
      disk: {
        type: "String",
        displayName: "Storage Disk",
        default: "local"
      },
      size: {
        type: "BigInt",
        displayName: "File Size (bytes)",
        unsigned: true
      },
      mimeType: {
        type: "String",
        displayName: "MIME Type"
      },
      fileableType: {
        type: "String",
        displayName: "Fileable Type"
      },
      fileableId: {
        type: "BigInt",
        displayName: "Fileable ID",
        unsigned: true
      },
      fileableField: {
        type: "String",
        displayName: "Fileable Field"
      }
    }
  };
}
function createFileLoadedSchema(schemasDir) {
  const definition = createFileSchemaDefinition();
  const filePath = path.join(schemasDir, "File.yaml");
  return {
    ...definition,
    name: FILE_SCHEMA_NAME,
    filePath,
    relativePath: "File.yaml"
  };
}
function generateFileSchemaYaml() {
  return `# File Schema - Polymorphic file storage
# Auto-generated by Omnify when File type is detected
# You can customize this schema as needed

displayName: File

options:
  timestamps: true
  tableName: files
  indexes:
    - columns: [fileableType, fileableId, fileableField]
      name: files_fileable_index

properties:
  path:
    type: String
    displayName: Storage Path

  disk:
    type: String
    displayName: Storage Disk
    default: local

  size:
    type: BigInt
    displayName: File Size (bytes)
    unsigned: true

  mimeType:
    type: String
    displayName: MIME Type

  fileableType:
    type: String
    displayName: Fileable Type

  fileableId:
    type: BigInt
    displayName: Fileable ID
    unsigned: true

  fileableField:
    type: String
    displayName: Fileable Field
`;
}
async function ensureFileSchema(schemas, schemasDir, autoCreate = false) {
  if (!schemasHaveFileProperties(schemas)) {
    return schemas;
  }
  if (schemas[FILE_SCHEMA_NAME]) {
    return schemas;
  }
  const fileSchema = createFileLoadedSchema(schemasDir);
  if (autoCreate) {
    const filePath = path.join(schemasDir, "File.yaml");
    const yamlContent = generateFileSchemaYaml();
    await fs.writeFile(filePath, yamlContent, "utf-8");
  }
  return {
    [FILE_SCHEMA_NAME]: fileSchema,
    ...schemas
  };
}

// src/validation/validator.ts
var import_omnify_types2 = require("@famgia/omnify-types");

// src/validation/types/base.ts
var BASE_PROPERTY_FIELDS = [
  "type",
  "displayName",
  "placeholder",
  // Placeholder for form inputs (supports multi-language)
  "nullable",
  "default",
  "unique",
  "primary",
  // Custom primary key (use with options.id: false)
  "description",
  "renamedFrom",
  "rules",
  // Validation rules (application-level only)
  "hidden",
  // Laravel: $hidden array
  "fillable",
  // Laravel: $fillable array (default true)
  "fields"
  // Per-field settings for compound types
];
var VALID_RULES_FIELDS = [
  // Basic
  "required",
  // String length
  "minLength",
  "maxLength",
  // Format (String only)
  "url",
  "uuid",
  "ip",
  "ipv4",
  "ipv6",
  // Character pattern (String only)
  "alpha",
  "alphaNum",
  "alphaDash",
  "numeric",
  "digits",
  "digitsBetween",
  // String matching (String only)
  "startsWith",
  "endsWith",
  "lowercase",
  "uppercase",
  // Numeric (Int/Float only)
  "min",
  "max",
  "between",
  "gt",
  "lt",
  "multipleOf",
  // Array
  "arrayMin",
  "arrayMax"
];
var RULES_TYPE_GROUPS = {
  string: ["String", "Text", "MediumText", "LongText", "Password", "Email"],
  numeric: ["TinyInt", "Int", "BigInt", "Float", "Decimal"],
  date: ["Date", "DateTime", "Time", "Timestamp"],
  any: []
  // 全タイプに適用可能
};
var RULES_TYPE_COMPATIBILITY = {
  // Basic - any type
  required: "any",
  // String length rules
  minLength: "string",
  maxLength: "string",
  // Format rules (String only)
  url: "string",
  uuid: "string",
  ip: "string",
  ipv4: "string",
  ipv6: "string",
  // Character pattern rules (String only)
  alpha: "string",
  alphaNum: "string",
  alphaDash: "string",
  numeric: "string",
  digits: "string",
  digitsBetween: "string",
  // String matching rules (String only)
  startsWith: "string",
  endsWith: "string",
  lowercase: "string",
  uppercase: "string",
  // Numeric rules (Int/Float only)
  min: "numeric",
  max: "numeric",
  between: "numeric",
  gt: "numeric",
  lt: "numeric",
  multipleOf: "numeric",
  // Array rules - handled separately
  arrayMin: "any",
  arrayMax: "any"
};
function isRuleCompatibleWithType(rule, propertyType) {
  const category = RULES_TYPE_COMPATIBILITY[rule];
  if (!category) return false;
  if (category === "any") return true;
  const allowedTypes = RULES_TYPE_GROUPS[category];
  return allowedTypes.includes(propertyType);
}
function createValidFields(additionalFields) {
  return [...BASE_PROPERTY_FIELDS, ...additionalFields];
}
function fullDbCompatibility() {
  return {
    mysql: "full",
    postgres: "full",
    sqlite: "full",
    sqlserver: "full"
  };
}

// src/validation/types/registry.ts
var TypeRegistry = class {
  types = /* @__PURE__ */ new Map();
  /**
   * Register a type definition.
   */
  register(type) {
    if (this.types.has(type.name)) {
      throw new Error(`Type '${type.name}' is already registered`);
    }
    this.types.set(type.name, type);
  }
  /**
   * Register multiple type definitions.
   */
  registerAll(types) {
    for (const type of types) {
      this.register(type);
    }
  }
  /**
   * Get a type definition by name.
   */
  get(name) {
    return this.types.get(name);
  }
  /**
   * Check if a type is registered.
   */
  has(name) {
    return this.types.has(name);
  }
  /**
   * Get valid fields for a type.
   * Returns base fields if type not found.
   */
  getValidFields(name) {
    const type = this.types.get(name);
    return type?.validFields ?? BASE_PROPERTY_FIELDS;
  }
  /**
   * Get database compatibility for a type.
   * Returns 'full' if type not found (custom types assumed compatible).
   */
  getDbCompatibility(name, driver) {
    const type = this.types.get(name);
    return type?.dbCompatibility[driver] ?? "full";
  }
  /**
   * Get default values for a type.
   */
  getDefaults(name) {
    return this.types.get(name)?.defaults;
  }
  /**
   * Validate a property using its type's validator.
   * Returns empty array if type not found (validation handled elsewhere).
   */
  validateProperty(propertyName, property, filePath) {
    const type = this.types.get(property.type);
    if (!type) {
      return [];
    }
    return type.validate(propertyName, property, filePath);
  }
  /**
   * Get all registered type names.
   */
  getAllTypeNames() {
    return [...this.types.keys()];
  }
  /**
   * Get all valid fields across ALL types.
   * Used to determine if a field is valid for any type.
   */
  getAllValidFields() {
    const allFields = /* @__PURE__ */ new Set();
    for (const type of this.types.values()) {
      for (const field of type.validFields) {
        allFields.add(field);
      }
    }
    return allFields;
  }
  /**
   * Check if a field is valid for any registered type.
   */
  isFieldValidForAnyType(field) {
    for (const type of this.types.values()) {
      if (type.validFields.includes(field)) {
        return true;
      }
    }
    return false;
  }
  /**
   * Get count of registered types.
   */
  get size() {
    return this.types.size;
  }
  /**
   * Clear all registered types.
   * Useful for testing.
   */
  clear() {
    this.types.clear();
  }
};
var typeRegistry = new TypeRegistry();

// src/validation/types/primitives.ts
function validateBooleanDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value).toLowerCase();
  if (!["true", "false", "1", "0"].includes(strValue)) {
    return { valid: false, error: "Must be true or false" };
  }
  return { valid: true };
}
var BooleanType = {
  name: "Boolean",
  category: "primitive",
  validFields: createValidFields([]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateBooleanDefault
};
var primitiveTypes = [
  BooleanType
];

// src/validation/types/text.ts
function validateTextDefault() {
  return { valid: true };
}
function validateEmailDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(strValue)) {
    return { valid: false, error: "Must be a valid email address" };
  }
  return { valid: true };
}
function buildLocation2(file) {
  return { file };
}
function validateLength(propertyName, property, filePath) {
  const errors = [];
  const { length } = property;
  if (length !== void 0) {
    if (typeof length !== "number" || length < 1 || length > 65535) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid length '${length}'`,
          buildLocation2(filePath),
          "length must be a positive number between 1 and 65535"
        )
      );
    }
  }
  return errors;
}
var StringType = {
  name: "String",
  category: "text",
  validFields: createValidFields(["length"]),
  dbCompatibility: fullDbCompatibility(),
  defaults: {
    // Default length depends on database, handled by generator
  },
  validate(propertyName, property, filePath) {
    return validateLength(propertyName, property, filePath);
  },
  validateDefaultValue: validateTextDefault
};
var TextType = {
  name: "Text",
  category: "text",
  validFields: createValidFields([]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateTextDefault
};
var MediumTextType = {
  name: "MediumText",
  category: "text",
  validFields: createValidFields([]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateTextDefault
};
var LongTextType = {
  name: "LongText",
  category: "text",
  validFields: createValidFields([]),
  dbCompatibility: {
    mysql: "full",
    postgres: "full",
    sqlite: "full",
    sqlserver: "limited"
    // Uses NVARCHAR(MAX)
  },
  validate() {
    return [];
  },
  validateDefaultValue: validateTextDefault
};
var EmailType = {
  name: "Email",
  category: "text",
  validFields: createValidFields(["length"]),
  dbCompatibility: fullDbCompatibility(),
  validate(propertyName, property, filePath) {
    return validateLength(propertyName, property, filePath);
  },
  validateDefaultValue: validateEmailDefault
};
var PasswordType = {
  name: "Password",
  category: "text",
  validFields: createValidFields(["length"]),
  dbCompatibility: fullDbCompatibility(),
  validate(propertyName, property, filePath) {
    return validateLength(propertyName, property, filePath);
  },
  validateDefaultValue: validateTextDefault
};
var textTypes = [
  StringType,
  TextType,
  MediumTextType,
  LongTextType,
  EmailType,
  PasswordType
];

// src/validation/types/numeric.ts
var INTEGER_DB_KEYWORDS = [
  "AUTO_INCREMENT",
  "IDENTITY",
  "SERIAL",
  "BIGSERIAL",
  "SMALLSERIAL",
  "NEXTVAL",
  "RAND()",
  "RANDOM()",
  "FLOOR()",
  "CEIL()",
  "ROUND()",
  "ABS()"
];
var FLOAT_DB_KEYWORDS = [
  "RAND()",
  "RANDOM()",
  "PI()",
  "FLOOR()",
  "CEIL()",
  "ROUND()",
  "ABS()",
  "SQRT()"
];
function isDbKeyword(value, keywords) {
  const upperValue = value.toUpperCase().trim();
  return keywords.some((keyword) => upperValue === keyword.toUpperCase());
}
function validateIntegerDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword(strValue, INTEGER_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. Use a static integer value instead.`
    };
  }
  if (!/^-?\d+$/.test(strValue)) {
    return { valid: false, error: "Must be an integer" };
  }
  return { valid: true };
}
function validateNumberDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword(strValue, FLOAT_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. Use a static number value instead.`
    };
  }
  if (!/^-?\d+(\.\d+)?$/.test(strValue)) {
    return { valid: false, error: "Must be a number" };
  }
  return { valid: true };
}
function buildLocation3(file) {
  return { file };
}
var TinyIntType = {
  name: "TinyInt",
  category: "numeric",
  validFields: createValidFields(["unsigned"]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateIntegerDefault
};
var IntType = {
  name: "Int",
  category: "numeric",
  validFields: createValidFields(["unsigned"]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateIntegerDefault
};
var BigIntType = {
  name: "BigInt",
  category: "numeric",
  validFields: createValidFields(["unsigned"]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateIntegerDefault
};
var FloatType = {
  name: "Float",
  category: "numeric",
  validFields: createValidFields(["unsigned"]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateNumberDefault
};
var DecimalType = {
  name: "Decimal",
  category: "numeric",
  validFields: createValidFields(["precision", "scale", "unsigned"]),
  dbCompatibility: {
    mysql: "full",
    postgres: "full",
    sqlite: "limited",
    // Stored as REAL, loses precision
    sqlserver: "full"
  },
  defaults: {
    // precision: 8, scale: 2 - handled by generator
  },
  validate(propertyName, property, filePath) {
    const errors = [];
    const { precision, scale } = property;
    if (precision !== void 0) {
      if (typeof precision !== "number" || precision < 1 || precision > 65) {
        errors.push(
          validationError(
            `Property '${propertyName}' has invalid precision '${precision}'`,
            buildLocation3(filePath),
            "precision must be a number between 1 and 65"
          )
        );
      }
    }
    if (scale !== void 0) {
      if (typeof scale !== "number" || scale < 0 || scale > 30) {
        errors.push(
          validationError(
            `Property '${propertyName}' has invalid scale '${scale}'`,
            buildLocation3(filePath),
            "scale must be a number between 0 and 30"
          )
        );
      }
      const effectivePrecision = typeof precision === "number" ? precision : 8;
      if (typeof scale === "number" && scale > effectivePrecision) {
        errors.push(
          validationError(
            `Property '${propertyName}' has scale (${scale}) greater than precision (${effectivePrecision})`,
            buildLocation3(filePath),
            "scale cannot be greater than precision"
          )
        );
      }
    }
    return errors;
  },
  validateDefaultValue: validateNumberDefault
};
var numericTypes = [
  TinyIntType,
  IntType,
  BigIntType,
  FloatType,
  DecimalType
];

// src/validation/types/temporal.ts
var TIMESTAMP_DB_KEYWORDS = [
  "CURRENT_TIMESTAMP",
  "NOW()",
  "GETDATE()",
  "GETUTCDATE()",
  "SYSDATE",
  "SYSDATETIME()",
  "LOCALTIMESTAMP",
  "CURRENT_DATE",
  "CURRENT_TIME"
];
var DATETIME_DB_KEYWORDS = [
  "CURRENT_TIMESTAMP",
  "NOW()",
  "GETDATE()",
  "GETUTCDATE()",
  "SYSDATE",
  "SYSDATETIME()",
  "LOCALTIMESTAMP"
];
var DATE_DB_KEYWORDS = [
  "CURRENT_DATE",
  "CURDATE()",
  "GETDATE()"
];
var TIME_DB_KEYWORDS = [
  "CURRENT_TIME",
  "CURTIME()"
];
function isDbKeyword2(value, keywords) {
  const upperValue = value.toUpperCase().trim();
  return keywords.some((keyword) => upperValue === keyword.toUpperCase());
}
function validateDateDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword2(strValue, DATE_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. Date type only accepts static date values in YYYY-MM-DD format.`
    };
  }
  if (!/^\d{4}-\d{2}-\d{2}$/.test(strValue)) {
    return { valid: false, error: "Must be in YYYY-MM-DD format" };
  }
  return { valid: true };
}
function validateTimeDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword2(strValue, TIME_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. Time type only accepts static time values in HH:MM or HH:MM:SS format.`
    };
  }
  if (!/^\d{2}:\d{2}(:\d{2})?$/.test(strValue)) {
    return { valid: false, error: "Must be in HH:MM or HH:MM:SS format" };
  }
  return { valid: true };
}
function validateDateTimeDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword2(strValue, DATETIME_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default for DateTime. Use a static datetime value in YYYY-MM-DD HH:MM:SS format instead.`
    };
  }
  if (!/^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}(:\d{2})?/.test(strValue)) {
    return { valid: false, error: "Must be in YYYY-MM-DD HH:MM:SS format" };
  }
  return { valid: true };
}
function validateTimestampDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword2(strValue, TIMESTAMP_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. Use 'useCurrent: true' instead for CURRENT_TIMESTAMP, or 'useCurrentOnUpdate: true' for ON UPDATE CURRENT_TIMESTAMP.`
    };
  }
  if (!/^\d{4}-\d{2}-\d{2}(T|\s)\d{2}:\d{2}(:\d{2})?/.test(strValue)) {
    return { valid: false, error: "Must be in YYYY-MM-DD HH:MM:SS format" };
  }
  return { valid: true };
}
var DateType = {
  name: "Date",
  category: "temporal",
  validFields: createValidFields([]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateDateDefault
};
var TimeType = {
  name: "Time",
  category: "temporal",
  validFields: createValidFields([]),
  dbCompatibility: {
    mysql: "full",
    postgres: "full",
    sqlite: "limited",
    // Stored as TEXT
    sqlserver: "full"
  },
  validate() {
    return [];
  },
  validateDefaultValue: validateTimeDefault
};
var DateTimeType = {
  name: "DateTime",
  category: "temporal",
  validFields: createValidFields([]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateDateTimeDefault
};
var TimestampType = {
  name: "Timestamp",
  category: "temporal",
  validFields: createValidFields(["useCurrent", "useCurrentOnUpdate"]),
  dbCompatibility: {
    mysql: "full",
    postgres: "full",
    sqlite: "limited",
    // Stored as INTEGER or TEXT
    sqlserver: "full"
  },
  validate() {
    return [];
  },
  validateDefaultValue: validateTimestampDefault
};
var temporalTypes = [
  DateType,
  TimeType,
  DateTimeType,
  TimestampType
];

// src/validation/types/special.ts
var FILE_VALID_FIELDS = ["multiple", "maxFiles", "accept", "maxSize"];
var UUID_DB_KEYWORDS = [
  "UUID()",
  "UUID_GENERATE_V4()",
  "GEN_RANDOM_UUID()",
  "NEWID()",
  "SYS_GUID()",
  "UUID_SHORT()"
];
var JSON_DB_KEYWORDS = [
  "JSON_ARRAY()",
  "JSON_OBJECT()"
];
function isDbKeyword3(value, keywords) {
  const upperValue = value.toUpperCase().trim();
  return keywords.some((keyword) => upperValue === keyword.toUpperCase());
}
function validateJsonDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword3(strValue, JSON_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. Use valid JSON like '{}' or '[]' instead.`
    };
  }
  try {
    JSON.parse(strValue);
    return { valid: true };
  } catch {
    return { valid: false, error: "Must be valid JSON" };
  }
}
function validateUuidDefault(value) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const strValue = String(value);
  if (isDbKeyword3(strValue, UUID_DB_KEYWORDS)) {
    return {
      valid: false,
      error: `Database function '${strValue}' is not allowed as default. For auto-generated UUIDs, configure at the application or database level, not in schema default.`
    };
  }
  if (!/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(strValue)) {
    return { valid: false, error: "Must be a valid UUID" };
  }
  return { valid: true };
}
function validateFileDefault() {
  return { valid: true };
}
function buildLocation4(file) {
  return { file };
}
var JsonType = {
  name: "Json",
  category: "special",
  validFields: createValidFields([]),
  dbCompatibility: {
    mysql: "full",
    // Native JSON type
    postgres: "full",
    // Native JSONB type
    sqlite: "limited",
    // Stored as TEXT
    sqlserver: "limited"
    // Stored as NVARCHAR(MAX)
  },
  validate() {
    return [];
  },
  validateDefaultValue: validateJsonDefault
};
var UuidType = {
  name: "Uuid",
  category: "special",
  validFields: createValidFields([]),
  dbCompatibility: fullDbCompatibility(),
  validate() {
    return [];
  },
  validateDefaultValue: validateUuidDefault
};
var FileType = {
  name: "File",
  category: "special",
  validFields: createValidFields(FILE_VALID_FIELDS),
  dbCompatibility: fullDbCompatibility(),
  validate(propertyName, property, filePath) {
    const errors = [];
    const {
      multiple,
      maxFiles,
      accept,
      maxSize
    } = property;
    if (multiple !== void 0 && typeof multiple !== "boolean") {
      errors.push(
        validationError(
          `Property '${propertyName}' multiple must be a boolean`,
          buildLocation4(filePath)
        )
      );
    }
    if (maxFiles !== void 0) {
      if (!multiple) {
        errors.push(
          validationError(
            `Property '${propertyName}' maxFiles is only valid when multiple=true`,
            buildLocation4(filePath),
            "Add multiple: true or remove maxFiles"
          )
        );
      } else if (typeof maxFiles !== "number" || maxFiles < 1 || !Number.isInteger(maxFiles)) {
        errors.push(
          validationError(
            `Property '${propertyName}' maxFiles must be a positive integer`,
            buildLocation4(filePath)
          )
        );
      }
    }
    if (accept !== void 0) {
      if (!Array.isArray(accept)) {
        errors.push(
          validationError(
            `Property '${propertyName}' accept must be an array of file extensions`,
            buildLocation4(filePath),
            "Example: accept: [jpg, png, pdf]"
          )
        );
      } else {
        for (const ext of accept) {
          if (typeof ext !== "string") {
            errors.push(
              validationError(
                `Property '${propertyName}' accept array contains non-string value`,
                buildLocation4(filePath)
              )
            );
            break;
          }
        }
      }
    }
    if (maxSize !== void 0) {
      if (typeof maxSize !== "number" || maxSize < 1 || !Number.isInteger(maxSize)) {
        errors.push(
          validationError(
            `Property '${propertyName}' maxSize must be a positive integer (KB)`,
            buildLocation4(filePath)
          )
        );
      }
    }
    return errors;
  },
  validateDefaultValue: validateFileDefault
};
var specialTypes = [
  JsonType,
  UuidType,
  FileType
];

// src/validation/types/enum.ts
var VALID_INLINE_ENUM_VALUE_FIELDS = /* @__PURE__ */ new Set(["value", "label", "extra"]);
function isInlineEnumValue(value) {
  return typeof value === "object" && value !== null && "value" in value;
}
function isValidLocalizedString(value) {
  if (typeof value === "string") {
    return true;
  }
  if (typeof value === "object" && value !== null && !Array.isArray(value)) {
    for (const v of Object.values(value)) {
      if (typeof v !== "string") {
        return false;
      }
    }
    return true;
  }
  return false;
}
function isValidExtraObject(value) {
  if (typeof value !== "object" || value === null || Array.isArray(value)) {
    return false;
  }
  for (const v of Object.values(value)) {
    if (typeof v !== "string" && typeof v !== "number" && typeof v !== "boolean") {
      return false;
    }
  }
  return true;
}
function validateInlineEnumValue(enumValue, propertyName, filePath, context) {
  const errors = [];
  const prefix = context ? `${context} ` : "";
  const valueStr = typeof enumValue.value === "string" ? `'${enumValue.value}'` : "";
  const location = prefix + (valueStr ? `enum value ${valueStr}` : "enum value");
  for (const field of Object.keys(enumValue)) {
    if (!VALID_INLINE_ENUM_VALUE_FIELDS.has(field)) {
      errors.push(
        validationError(
          `Property '${propertyName}' ${location} has unknown field '${field}'`,
          { file: filePath },
          `Valid fields: ${[...VALID_INLINE_ENUM_VALUE_FIELDS].join(", ")}`
        )
      );
    }
  }
  if (!("value" in enumValue)) {
    errors.push(
      validationError(
        `Property '${propertyName}' ${location} is missing required 'value' field`,
        { file: filePath },
        'Use format: { value: "string", label: "Display Label" }'
      )
    );
  } else if (typeof enumValue.value !== "string") {
    errors.push(
      validationError(
        `Property '${propertyName}' ${location} 'value' must be a string`,
        { file: filePath },
        'Use format: { value: "string", label: "Display Label" }'
      )
    );
  }
  if ("label" in enumValue && enumValue.label !== void 0) {
    if (!isValidLocalizedString(enumValue.label)) {
      errors.push(
        validationError(
          `Property '${propertyName}' ${location} 'label' must be a string or locale map`,
          { file: filePath },
          'Use: label: "Text" or label: { en: "Text", ja: "\u30C6\u30AD\u30B9\u30C8" }'
        )
      );
    }
  }
  if ("extra" in enumValue && enumValue.extra !== void 0) {
    if (!isValidExtraObject(enumValue.extra)) {
      errors.push(
        validationError(
          `Property '${propertyName}' ${location} 'extra' must be an object with string/number/boolean values`,
          { file: filePath },
          'Use: extra: { color: "red", sortOrder: 1, active: true }'
        )
      );
    }
  }
  return errors;
}
function getEnumStringValue(value) {
  return typeof value === "string" ? value : value.value;
}
function validateEnumDefault(value, property) {
  if (value === void 0 || value === null || value === "") {
    return { valid: true };
  }
  const enumValues = property?.enum;
  if (!enumValues || !Array.isArray(enumValues)) {
    return { valid: true };
  }
  const strValue = String(value);
  const validValues = enumValues.map(getEnumStringValue);
  if (!validValues.includes(strValue)) {
    return {
      valid: false,
      error: `Must be one of: ${validValues.join(", ")}`
    };
  }
  return { valid: true };
}
function buildLocation5(file) {
  return { file };
}
var EnumType = {
  name: "Enum",
  category: "enum",
  validFields: createValidFields(["enum"]),
  requiredFields: ["enum"],
  dbCompatibility: fullDbCompatibility(),
  validate(propertyName, property, filePath) {
    const errors = [];
    const { enum: enumValues } = property;
    if (enumValues === void 0) {
      errors.push(
        validationError(
          `Property '${propertyName}' of type 'Enum' requires 'enum' field`,
          buildLocation5(filePath),
          "Add enum values: enum: [value1, value2]"
        )
      );
    } else if (!Array.isArray(enumValues)) {
      errors.push(
        validationError(
          `Property '${propertyName}' enum field must be an array`,
          buildLocation5(filePath),
          "enum: [value1, value2]"
        )
      );
    } else if (enumValues.length === 0) {
      errors.push(
        validationError(
          `Property '${propertyName}' enum field cannot be empty`,
          buildLocation5(filePath),
          "Add at least one enum value"
        )
      );
    } else {
      const seen = /* @__PURE__ */ new Set();
      for (const value of enumValues) {
        if (typeof value === "string") {
          if (seen.has(value)) {
            errors.push(
              validationError(
                `Property '${propertyName}' has duplicate enum value '${value}'`,
                buildLocation5(filePath)
              )
            );
          } else {
            seen.add(value);
          }
        } else if (isInlineEnumValue(value)) {
          const valueErrors = validateInlineEnumValue(
            value,
            propertyName,
            filePath
          );
          errors.push(...valueErrors);
          if (typeof value.value === "string") {
            if (seen.has(value.value)) {
              errors.push(
                validationError(
                  `Property '${propertyName}' has duplicate enum value '${value.value}'`,
                  buildLocation5(filePath)
                )
              );
            } else {
              seen.add(value.value);
            }
          }
        } else {
          errors.push(
            validationError(
              `Property '${propertyName}' enum values must be strings or objects with 'value' field`,
              buildLocation5(filePath),
              'Use: "value" or { value: "value", label: "Label" }'
            )
          );
        }
      }
    }
    return errors;
  },
  validateDefaultValue: validateEnumDefault
};
var EnumRefType = {
  name: "EnumRef",
  category: "enum",
  validFields: createValidFields(["enum"]),
  requiredFields: ["enum"],
  dbCompatibility: fullDbCompatibility(),
  validate(propertyName, property, filePath) {
    const errors = [];
    const { enum: enumRef } = property;
    if (enumRef === void 0) {
      errors.push(
        validationError(
          `Property '${propertyName}' of type 'EnumRef' requires 'enum' field`,
          buildLocation5(filePath),
          "Add enum schema reference: enum: EnumSchemaName"
        )
      );
    } else if (typeof enumRef !== "string") {
      errors.push(
        validationError(
          `Property '${propertyName}' enum field must be a string (enum schema name)`,
          buildLocation5(filePath),
          "enum: EnumSchemaName"
        )
      );
    } else if (enumRef.trim() === "") {
      errors.push(
        validationError(
          `Property '${propertyName}' enum field cannot be empty`,
          buildLocation5(filePath),
          "Add enum schema name"
        )
      );
    }
    return errors;
  },
  // EnumRef default value validation requires schema context
  // This is handled at a higher level (validator.ts) where schemas are available
  validateDefaultValue: () => ({ valid: true })
};
var enumTypes = [
  EnumType,
  EnumRefType
];

// src/validation/types/relations.ts
function buildLocation6(file) {
  return { file };
}
var VALID_RELATIONS = [
  "OneToOne",
  "OneToMany",
  "ManyToOne",
  "ManyToMany",
  // Polymorphic relations
  "MorphTo",
  "MorphOne",
  "MorphMany",
  "MorphToMany",
  "MorphedByMany"
];
var MORPH_TO_RELATIONS = ["MorphTo"];
var MORPH_INVERSE_RELATIONS = [
  "MorphOne",
  "MorphMany"
];
var VALID_REFERENTIAL_ACTIONS = [
  "CASCADE",
  "SET NULL",
  "SET DEFAULT",
  "RESTRICT",
  "NO ACTION"
];
var PIVOT_TABLE_RELATIONS = [
  "ManyToMany",
  "MorphToMany"
];
var VALID_PIVOT_FIELD_TYPES = [
  "String",
  "Int",
  "BigInt",
  "Float",
  "Decimal",
  "Boolean",
  "Text",
  "Date",
  "Time",
  "Timestamp",
  "Json",
  "Enum"
];
var ASSOCIATION_FIELDS = [
  "relation",
  "target",
  "targets",
  // For MorphTo: array of target schema names
  "morphName",
  // For MorphOne/MorphMany/MorphedByMany: polymorphic name
  "inversedBy",
  "mappedBy",
  "onDelete",
  "onUpdate",
  "owning",
  "joinTable",
  "pivotFields"
  // For ManyToMany/MorphToMany: additional fields on pivot table
];
var AssociationType = {
  name: "Association",
  category: "relation",
  validFields: createValidFields(ASSOCIATION_FIELDS),
  requiredFields: ["relation"],
  dbCompatibility: fullDbCompatibility(),
  validate(propertyName, property, filePath) {
    const errors = [];
    const {
      relation,
      target,
      targets,
      morphName,
      onDelete,
      onUpdate
    } = property;
    if (relation === void 0) {
      errors.push(
        validationError(
          `Property '${propertyName}' of type 'Association' requires 'relation' field`,
          buildLocation6(filePath),
          "Add relation: OneToOne, OneToMany, ManyToOne, ManyToMany, MorphTo, MorphOne, MorphMany, MorphToMany, or MorphedByMany"
        )
      );
      return errors;
    }
    if (typeof relation !== "string") {
      errors.push(
        validationError(
          `Property '${propertyName}' relation field must be a string`,
          buildLocation6(filePath)
        )
      );
      return errors;
    }
    if (!VALID_RELATIONS.includes(relation)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid relation '${relation}'`,
          buildLocation6(filePath),
          `Use one of: ${VALID_RELATIONS.join(", ")}`
        )
      );
      return errors;
    }
    const relationTyped = relation;
    if (MORPH_TO_RELATIONS.includes(relationTyped)) {
      if (targets === void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation 'MorphTo' requires 'targets' field`,
            buildLocation6(filePath),
            "Add targets: [Post, Video, Image]"
          )
        );
      } else if (!Array.isArray(targets)) {
        errors.push(
          validationError(
            `Property '${propertyName}' targets field must be an array of schema names`,
            buildLocation6(filePath),
            "Example: targets: [Post, Video, Image]"
          )
        );
      } else if (targets.length === 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' targets array cannot be empty`,
            buildLocation6(filePath),
            "Add at least one target schema"
          )
        );
      } else {
        for (const t of targets) {
          if (typeof t !== "string") {
            errors.push(
              validationError(
                `Property '${propertyName}' targets array contains non-string value`,
                buildLocation6(filePath)
              )
            );
          }
        }
      }
      if (target !== void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation 'MorphTo' should use 'targets' (plural) not 'target'`,
            buildLocation6(filePath),
            "Change target to targets array"
          )
        );
      }
    } else if (MORPH_INVERSE_RELATIONS.includes(relationTyped)) {
      if (target === void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation '${relation}' requires 'target' field`,
            buildLocation6(filePath),
            "Add target schema name: target: Comment"
          )
        );
      } else if (typeof target !== "string") {
        errors.push(
          validationError(
            `Property '${propertyName}' target field must be a string`,
            buildLocation6(filePath)
          )
        );
      }
      if (morphName === void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation '${relation}' requires 'morphName' field`,
            buildLocation6(filePath),
            "Add morphName to match the MorphTo property name (e.g., morphName: commentable)"
          )
        );
      } else if (typeof morphName !== "string") {
        errors.push(
          validationError(
            `Property '${propertyName}' morphName field must be a string`,
            buildLocation6(filePath)
          )
        );
      }
    } else if (relationTyped === "MorphToMany") {
      if (target === void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation 'MorphToMany' requires 'target' field`,
            buildLocation6(filePath),
            "Add target schema name: target: Tag"
          )
        );
      } else if (typeof target !== "string") {
        errors.push(
          validationError(
            `Property '${propertyName}' target field must be a string`,
            buildLocation6(filePath)
          )
        );
      }
    } else if (relationTyped === "MorphedByMany") {
      if (target === void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation 'MorphedByMany' requires 'target' field`,
            buildLocation6(filePath),
            "Add target schema name: target: Post"
          )
        );
      } else if (typeof target !== "string") {
        errors.push(
          validationError(
            `Property '${propertyName}' target field must be a string`,
            buildLocation6(filePath)
          )
        );
      }
      if (morphName !== void 0 && typeof morphName !== "string") {
        errors.push(
          validationError(
            `Property '${propertyName}' morphName field must be a string`,
            buildLocation6(filePath)
          )
        );
      }
    } else {
      if (target === void 0) {
        errors.push(
          validationError(
            `Property '${propertyName}' of type 'Association' requires 'target' field`,
            buildLocation6(filePath),
            "Add target schema name: target: User"
          )
        );
      } else if (typeof target !== "string") {
        errors.push(
          validationError(
            `Property '${propertyName}' target field must be a string`,
            buildLocation6(filePath)
          )
        );
      }
    }
    if (onDelete !== void 0 && typeof onDelete === "string") {
      if (!VALID_REFERENTIAL_ACTIONS.includes(onDelete)) {
        errors.push(
          validationError(
            `Property '${propertyName}' has invalid onDelete action '${onDelete}'`,
            buildLocation6(filePath),
            `Use one of: ${VALID_REFERENTIAL_ACTIONS.join(", ")}`
          )
        );
      }
    }
    if (onUpdate !== void 0 && typeof onUpdate === "string") {
      if (!VALID_REFERENTIAL_ACTIONS.includes(onUpdate)) {
        errors.push(
          validationError(
            `Property '${propertyName}' has invalid onUpdate action '${onUpdate}'`,
            buildLocation6(filePath),
            `Use one of: ${VALID_REFERENTIAL_ACTIONS.join(", ")}`
          )
        );
      }
    }
    const pivotFields = property.pivotFields;
    if (pivotFields !== void 0) {
      if (!PIVOT_TABLE_RELATIONS.includes(relationTyped)) {
        errors.push(
          validationError(
            `Property '${propertyName}' with relation '${relation}' cannot have pivotFields`,
            buildLocation6(filePath),
            "pivotFields is only allowed for ManyToMany and MorphToMany relations"
          )
        );
      } else if (typeof pivotFields !== "object" || pivotFields === null || Array.isArray(pivotFields)) {
        errors.push(
          validationError(
            `Property '${propertyName}' pivotFields must be an object`,
            buildLocation6(filePath),
            'Example: pivotFields: { assigned_at: { type: "Timestamp" } }'
          )
        );
      } else {
        for (const [fieldName, fieldDef] of Object.entries(pivotFields)) {
          if (typeof fieldDef !== "object" || fieldDef === null) {
            errors.push(
              validationError(
                `Pivot field '${fieldName}' in '${propertyName}' must be an object`,
                buildLocation6(filePath)
              )
            );
            continue;
          }
          const { type: fieldType } = fieldDef;
          if (fieldType === void 0) {
            errors.push(
              validationError(
                `Pivot field '${fieldName}' in '${propertyName}' requires 'type' field`,
                buildLocation6(filePath),
                `Example: ${fieldName}: { type: "String" }`
              )
            );
          } else if (typeof fieldType !== "string") {
            errors.push(
              validationError(
                `Pivot field '${fieldName}' in '${propertyName}' type must be a string`,
                buildLocation6(filePath)
              )
            );
          } else if (fieldType === "Association") {
            errors.push(
              validationError(
                `Pivot field '${fieldName}' in '${propertyName}' cannot be of type 'Association'`,
                buildLocation6(filePath),
                "Pivot fields only support basic types like String, Int, Boolean, Timestamp, etc."
              )
            );
          } else if (!VALID_PIVOT_FIELD_TYPES.includes(fieldType)) {
            errors.push(
              validationError(
                `Pivot field '${fieldName}' in '${propertyName}' has unsupported type '${fieldType}'`,
                buildLocation6(filePath),
                `Supported types: ${VALID_PIVOT_FIELD_TYPES.join(", ")}`
              )
            );
          } else if (fieldType === "Enum") {
            const { enum: enumValues } = fieldDef;
            if (enumValues === void 0) {
              errors.push(
                validationError(
                  `Pivot field '${fieldName}' in '${propertyName}' of type 'Enum' requires 'enum' field`,
                  buildLocation6(filePath),
                  `Example: ${fieldName}: { type: "Enum", enum: [value1, value2] }`
                )
              );
            } else if (!Array.isArray(enumValues)) {
              errors.push(
                validationError(
                  `Pivot field '${fieldName}' in '${propertyName}' enum field must be an array`,
                  buildLocation6(filePath),
                  'enum: [value1, value2] or enum: [{ value: "v1", label: "Label 1" }]'
                )
              );
            } else if (enumValues.length === 0) {
              errors.push(
                validationError(
                  `Pivot field '${fieldName}' in '${propertyName}' enum field cannot be empty`,
                  buildLocation6(filePath),
                  "Add at least one enum value"
                )
              );
            } else {
              const seen = /* @__PURE__ */ new Set();
              const context = `pivot field '${fieldName}' in`;
              for (const value of enumValues) {
                if (typeof value === "string") {
                  if (seen.has(value)) {
                    errors.push(
                      validationError(
                        `Pivot field '${fieldName}' in '${propertyName}' has duplicate enum value '${value}'`,
                        buildLocation6(filePath)
                      )
                    );
                  } else {
                    seen.add(value);
                  }
                } else if (typeof value === "object" && value !== null && "value" in value) {
                  const valueErrors = validateInlineEnumValue(
                    value,
                    propertyName,
                    filePath,
                    context
                  );
                  errors.push(...valueErrors);
                  const objValue = value.value;
                  if (typeof objValue === "string") {
                    if (seen.has(objValue)) {
                      errors.push(
                        validationError(
                          `Pivot field '${fieldName}' in '${propertyName}' has duplicate enum value '${objValue}'`,
                          buildLocation6(filePath)
                        )
                      );
                    } else {
                      seen.add(objValue);
                    }
                  }
                } else {
                  errors.push(
                    validationError(
                      `Pivot field '${fieldName}' in '${propertyName}' enum values must be strings or objects with 'value' field`,
                      buildLocation6(filePath),
                      'Use: "value" or { value: "value", label: "Label" }'
                    )
                  );
                }
              }
            }
          }
        }
      }
    }
    return errors;
  }
};
var relationTypes = [
  AssociationType
];

// src/validation/types/index.ts
var allBuiltInTypes = [
  ...primitiveTypes,
  ...textTypes,
  ...numericTypes,
  ...temporalTypes,
  ...specialTypes,
  ...enumTypes,
  ...relationTypes
];
function registerBuiltInTypes() {
  for (const type of allBuiltInTypes) {
    if (!typeRegistry.has(type.name)) {
      typeRegistry.register(type);
    }
  }
}
registerBuiltInTypes();
function validateDefaultValue(typeName, value, property) {
  const typeDef = typeRegistry.get(typeName);
  if (!typeDef) {
    return { valid: true };
  }
  if (typeDef.validateDefaultValue) {
    return typeDef.validateDefaultValue(value, property);
  }
  return { valid: true };
}

// src/validation/validator.ts
var VALID_ID_TYPES = ["Int", "BigInt", "Uuid", "String"];
function toSnakeCase(str) {
  return str.replace(/([a-z])([A-Z])/g, "$1_$2").toLowerCase();
}
function buildLocation7(file, line, column) {
  const loc = { file };
  if (line !== void 0) {
    loc.line = line;
  }
  if (column !== void 0) {
    loc.column = column;
  }
  return loc;
}
function validateUnknownSchemaFields(schema, filePath) {
  const errors = [];
  const unknownFields = schema._unknownFields;
  if (!unknownFields || unknownFields.length === 0) {
    return errors;
  }
  for (const field of unknownFields) {
    let suggestion = `Valid schema fields: kind, target, priority, pivotFor, displayName, titleIndex, group, options, properties, values`;
    if (field === "associations") {
      suggestion = `Associations should be defined inside 'properties' with type: Association.
Example:
  properties:
    author:
      type: Association
      relation: ManyToOne
      target: User
      onDelete: CASCADE`;
    } else if (field === "indexes") {
      suggestion = `Indexes should be inside 'options.indexes'.
Example:
  options:
    indexes:
      - columns: [email]
        unique: true`;
    } else if (field === "required") {
      suggestion = `'required' is not a valid field. Use 'nullable: false' on properties (default is not nullable).
Example:
  properties:
    email:
      type: String
      # not nullable by default, explicitly use nullable: true to make optional`;
    } else if (field === "hidden") {
      suggestion = `'hidden' is not a schema-level field. Hidden fields should be handled by your framework.
For Laravel, the model generator can handle this, but you need to use a custom property.`;
    }
    errors.push(
      validationError(
        `Unknown schema field '${field}'`,
        buildLocation7(filePath),
        suggestion
      )
    );
  }
  return errors;
}
function validateUnknownOptionsFields(schema, filePath) {
  const errors = [];
  const unknownOptionsFields = schema._unknownOptionsFields;
  if (!unknownOptionsFields || unknownOptionsFields.length === 0) {
    return errors;
  }
  for (const field of unknownOptionsFields) {
    errors.push(
      validationError(
        `Unknown option field '${field}'`,
        buildLocation7(filePath),
        `Valid option fields: id, idType, timestamps, softDelete, unique, indexes, translations, tableName, authenticatable, authenticatableLoginIdField, authenticatablePasswordField, authenticatableGuardName`
      )
    );
  }
  return errors;
}
function validatePropertyFormat(schema, filePath) {
  const errors = [];
  const invalidProperties = schema._invalidProperties;
  if (!invalidProperties || invalidProperties.length === 0) {
    return errors;
  }
  for (const invalid of invalidProperties) {
    const valueType = typeof invalid.value;
    const valuePreview = valueType === "string" ? `"${invalid.value}"` : String(invalid.value);
    errors.push(
      validationError(
        `Property '${invalid.propertyName}' has invalid format: got ${valueType} (${valuePreview})`,
        buildLocation7(filePath),
        invalid.expectedFormat
      )
    );
  }
  return errors;
}
function validateDbCompatibility(propertyName, property, filePath, databaseDriver) {
  const errors = [];
  const warnings = [];
  if (!databaseDriver || !property.type) {
    return { errors, warnings };
  }
  const compatibility = typeRegistry.getDbCompatibility(property.type, databaseDriver);
  if (compatibility === "unsupported") {
    errors.push(
      validationError(
        `Property '${propertyName}' uses type '${property.type}' which is not supported in ${databaseDriver}`,
        buildLocation7(filePath),
        `Consider using a different type or database driver`
      )
    );
  } else if (compatibility === "limited") {
    warnings.push(
      validationError(
        `Property '${propertyName}' uses type '${property.type}' which has limited support in ${databaseDriver}`,
        buildLocation7(filePath),
        `The type will work but may have precision or feature limitations`
      )
    );
  }
  return { errors, warnings };
}
function validateUnknownFieldsDetailed(propertyName, property, filePath, customTypeDefinitions) {
  const errors = [];
  const warnings = [];
  if (!property.type) {
    return { errors, warnings };
  }
  let validFields;
  const isBuiltIn = typeRegistry.has(property.type);
  if (isBuiltIn) {
    validFields = typeRegistry.getValidFields(property.type);
  } else {
    const customTypeDef = customTypeDefinitions?.get(property.type);
    if (customTypeDef?.validFields) {
      validFields = [...BASE_PROPERTY_FIELDS, ...customTypeDef.validFields];
    } else {
      validFields = [...BASE_PROPERTY_FIELDS];
    }
  }
  const validFieldsSet = new Set(validFields);
  for (const field of Object.keys(property)) {
    if (field.startsWith("_")) continue;
    if (validFieldsSet.has(field)) continue;
    const isValidForOtherType = typeRegistry.isFieldValidForAnyType(field);
    if (isValidForOtherType) {
      errors.push(
        validationError(
          `Property '${propertyName}' of type '${property.type}' has invalid field '${field}'`,
          buildLocation7(filePath),
          `'${field}' is not valid for type '${property.type}'. Valid fields: ${validFields.join(", ")}`
        )
      );
    } else {
      errors.push(
        validationError(
          `Property '${propertyName}' has unknown field '${field}'`,
          buildLocation7(filePath),
          getSuggestionForUnknownField(field)
        )
      );
    }
  }
  return { errors, warnings };
}
function getSuggestionForUnknownField(field) {
  if (field === "required") {
    return `'required' should be inside 'rules' field.
Example:
  name:
    type: String
    rules:
      required: true
Note: rules.required is for validation only, does NOT affect database nullable.
Recommended: set 'nullable: false' if required: true.`;
  }
  if (field === "maxLength" || field === "minLength") {
    return `'${field}' should be inside 'rules' field.
Example:
  name:
    type: String
    length: 255  # Database column size
    rules:
      minLength: 5
      maxLength: 100
Note: 'length' is for database column size, 'rules.maxLength' is for validation only.`;
  }
  if (field === "foreignKey") {
    return `'foreignKey' is not needed. Omnify auto-generates foreign keys from Association properties.
The foreign key name is derived from the property name + '_id'.
Example:
  author:
    type: Association
    relation: ManyToOne
    target: User
    # Creates author_id column automatically`;
  }
  return `Unknown field '${field}'. Valid property fields: type, displayName, placeholder, nullable, default, unique, primary, description, length, unsigned, precision, scale, enum, relation, target, onDelete, onUpdate, joinTable, rules, hidden, fillable, fields`;
}
function validateRules(propertyName, property, filePath) {
  const errors = [];
  const rules = property.rules;
  if (!rules || typeof rules !== "object") {
    return errors;
  }
  const propertyType = property.type;
  const validRulesSet = new Set(VALID_RULES_FIELDS);
  for (const field of Object.keys(rules)) {
    if (!validRulesSet.has(field)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has unknown field in rules: '${field}'`,
          buildLocation7(filePath),
          `Valid rules fields: ${VALID_RULES_FIELDS.join(", ")}`
        )
      );
    }
  }
  for (const [ruleName, ruleValue] of Object.entries(rules)) {
    if (ruleValue === void 0 || ruleValue === null) continue;
    if (!validRulesSet.has(ruleName)) continue;
    if (!isRuleCompatibleWithType(ruleName, propertyType)) {
      const stringTypes = RULES_TYPE_GROUPS.string.join(", ");
      const numericTypes2 = RULES_TYPE_GROUPS.numeric.join(", ");
      let allowedTypes = "";
      if ([
        "minLength",
        "maxLength",
        "url",
        "uuid",
        "ip",
        "ipv4",
        "ipv6",
        "alpha",
        "alphaNum",
        "alphaDash",
        "numeric",
        "digits",
        "digitsBetween",
        "startsWith",
        "endsWith",
        "lowercase",
        "uppercase"
      ].includes(ruleName)) {
        allowedTypes = stringTypes;
      } else if (["min", "max", "between", "gt", "lt", "multipleOf"].includes(ruleName)) {
        allowedTypes = numericTypes2;
      }
      if (allowedTypes) {
        errors.push(
          validationError(
            `Property '${propertyName}' of type '${propertyType}' cannot use rules.${ruleName}`,
            buildLocation7(filePath),
            `rules.${ruleName} is only valid for types: ${allowedTypes}`
          )
        );
      }
    }
  }
  const {
    required,
    minLength,
    maxLength,
    url,
    uuid,
    ip,
    ipv4,
    ipv6,
    alpha,
    alphaNum,
    alphaDash,
    numeric,
    lowercase,
    uppercase,
    digits,
    digitsBetween,
    startsWith,
    endsWith,
    min,
    max,
    between,
    gt,
    lt,
    multipleOf,
    arrayMin,
    arrayMax
  } = rules;
  const booleanRules = { required, url, uuid, ip, ipv4, ipv6, alpha, alphaNum, alphaDash, numeric, lowercase, uppercase };
  for (const [name, value] of Object.entries(booleanRules)) {
    if (value !== void 0 && typeof value !== "boolean") {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.${name} value`,
          buildLocation7(filePath),
          `rules.${name} must be a boolean (true or false)`
        )
      );
    }
  }
  if (minLength !== void 0 && isRuleCompatibleWithType("minLength", propertyType)) {
    if (typeof minLength !== "number" || minLength < 0 || !Number.isInteger(minLength)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.minLength '${minLength}'`,
          buildLocation7(filePath),
          "rules.minLength must be a non-negative integer"
        )
      );
    }
  }
  if (maxLength !== void 0 && isRuleCompatibleWithType("maxLength", propertyType)) {
    if (typeof maxLength !== "number" || maxLength < 1 || !Number.isInteger(maxLength)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.maxLength '${maxLength}'`,
          buildLocation7(filePath),
          "rules.maxLength must be a positive integer"
        )
      );
    } else {
      const dbLength = property.length;
      if (dbLength !== void 0 && typeof dbLength === "number" && maxLength > dbLength) {
        errors.push(
          validationError(
            `Property '${propertyName}' has rules.maxLength (${maxLength}) greater than length (${dbLength})`,
            buildLocation7(filePath),
            "rules.maxLength must be <= length (database column size)"
          )
        );
      }
    }
  }
  if (typeof minLength === "number" && typeof maxLength === "number" && minLength > maxLength) {
    errors.push(
      validationError(
        `Property '${propertyName}' has rules.minLength (${minLength}) > rules.maxLength (${maxLength})`,
        buildLocation7(filePath),
        "rules.minLength must be <= rules.maxLength"
      )
    );
  }
  if (digits !== void 0) {
    if (typeof digits !== "number" || digits < 1 || !Number.isInteger(digits)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.digits '${digits}'`,
          buildLocation7(filePath),
          "rules.digits must be a positive integer"
        )
      );
    }
  }
  if (digitsBetween !== void 0) {
    if (!Array.isArray(digitsBetween) || digitsBetween.length !== 2 || typeof digitsBetween[0] !== "number" || typeof digitsBetween[1] !== "number") {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.digitsBetween`,
          buildLocation7(filePath),
          "rules.digitsBetween must be [min, max] tuple of numbers"
        )
      );
    } else if (digitsBetween[0] > digitsBetween[1]) {
      errors.push(
        validationError(
          `Property '${propertyName}' has rules.digitsBetween[0] (${digitsBetween[0]}) > [1] (${digitsBetween[1]})`,
          buildLocation7(filePath),
          "First value must be <= second value"
        )
      );
    }
  }
  if (startsWith !== void 0) {
    if (typeof startsWith !== "string" && (!Array.isArray(startsWith) || !startsWith.every((s) => typeof s === "string"))) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.startsWith`,
          buildLocation7(filePath),
          "rules.startsWith must be a string or array of strings"
        )
      );
    }
  }
  if (endsWith !== void 0) {
    if (typeof endsWith !== "string" && (!Array.isArray(endsWith) || !endsWith.every((s) => typeof s === "string"))) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.endsWith`,
          buildLocation7(filePath),
          "rules.endsWith must be a string or array of strings"
        )
      );
    }
  }
  const numericSingleRules = { min, max, gt, lt, multipleOf };
  for (const [name, value] of Object.entries(numericSingleRules)) {
    if (value !== void 0 && isRuleCompatibleWithType(name, propertyType)) {
      if (typeof value !== "number") {
        errors.push(
          validationError(
            `Property '${propertyName}' has invalid rules.${name} '${value}'`,
            buildLocation7(filePath),
            `rules.${name} must be a number`
          )
        );
      }
    }
  }
  if (between !== void 0 && isRuleCompatibleWithType("between", propertyType)) {
    if (!Array.isArray(between) || between.length !== 2 || typeof between[0] !== "number" || typeof between[1] !== "number") {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.between`,
          buildLocation7(filePath),
          "rules.between must be [min, max] tuple of numbers"
        )
      );
    } else if (between[0] > between[1]) {
      errors.push(
        validationError(
          `Property '${propertyName}' has rules.between[0] (${between[0]}) > [1] (${between[1]})`,
          buildLocation7(filePath),
          "First value must be <= second value"
        )
      );
    }
  }
  if (typeof min === "number" && typeof max === "number" && min > max) {
    errors.push(
      validationError(
        `Property '${propertyName}' has rules.min (${min}) > rules.max (${max})`,
        buildLocation7(filePath),
        "rules.min must be <= rules.max"
      )
    );
  }
  if (typeof multipleOf === "number" && multipleOf <= 0) {
    errors.push(
      validationError(
        `Property '${propertyName}' has invalid rules.multipleOf '${multipleOf}'`,
        buildLocation7(filePath),
        "rules.multipleOf must be a positive number"
      )
    );
  }
  if (arrayMin !== void 0) {
    if (typeof arrayMin !== "number" || arrayMin < 0 || !Number.isInteger(arrayMin)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.arrayMin '${arrayMin}'`,
          buildLocation7(filePath),
          "rules.arrayMin must be a non-negative integer"
        )
      );
    }
  }
  if (arrayMax !== void 0) {
    if (typeof arrayMax !== "number" || arrayMax < 1 || !Number.isInteger(arrayMax)) {
      errors.push(
        validationError(
          `Property '${propertyName}' has invalid rules.arrayMax '${arrayMax}'`,
          buildLocation7(filePath),
          "rules.arrayMax must be a positive integer"
        )
      );
    }
  }
  if (typeof arrayMin === "number" && typeof arrayMax === "number" && arrayMin > arrayMax) {
    errors.push(
      validationError(
        `Property '${propertyName}' has rules.arrayMin (${arrayMin}) > rules.arrayMax (${arrayMax})`,
        buildLocation7(filePath),
        "rules.arrayMin must be <= rules.arrayMax"
      )
    );
  }
  return errors;
}
function validatePropertyType(propertyName, property, filePath, customTypes = []) {
  const errors = [];
  if (!property.type) {
    errors.push(
      missingFieldError("type", buildLocation7(filePath))
    );
    return errors;
  }
  const isBuiltIn = typeRegistry.has(property.type);
  const isCustom = customTypes.includes(property.type);
  if (!isBuiltIn && !isCustom) {
    errors.push(
      invalidPropertyTypeError(
        property.type,
        buildLocation7(filePath),
        typeRegistry.getAllTypeNames()
      )
    );
    return errors;
  }
  if (isBuiltIn) {
    const typeErrors = typeRegistry.validateProperty(propertyName, property, filePath);
    errors.push(...typeErrors);
  }
  return errors;
}
function validateProperties(schema, filePath, customTypes = []) {
  const errors = [];
  if (!schema.properties) {
    if (schema.kind !== "enum") {
    }
    return errors;
  }
  for (const [name, property] of Object.entries(schema.properties)) {
    const propErrors = validatePropertyType(name, property, filePath, customTypes);
    errors.push(...propErrors);
  }
  return errors;
}
var MORPH_TO_RELATIONS2 = ["MorphTo"];
var MORPH_INVERSE_RELATIONS2 = ["MorphOne", "MorphMany"];
function validateAssociations(schema, allSchemas) {
  const errors = [];
  if (!schema.properties) {
    return errors;
  }
  const availableSchemas = Object.keys(allSchemas);
  for (const [name, property] of Object.entries(schema.properties)) {
    if (property.type !== "Association") {
      continue;
    }
    const assocProp = property;
    if (assocProp.relation && !VALID_RELATIONS.includes(assocProp.relation)) {
      errors.push(
        validationError(
          `Property '${name}' has invalid relation '${assocProp.relation}'`,
          buildLocation7(schema.filePath),
          `Use one of: ${VALID_RELATIONS.join(", ")}`
        )
      );
    }
    const relation = assocProp.relation;
    if (relation && MORPH_TO_RELATIONS2.includes(relation)) {
      if (assocProp.targets) {
        for (const target of assocProp.targets) {
          if (!availableSchemas.includes(target)) {
            errors.push(
              invalidAssociationTargetError(
                target,
                buildLocation7(schema.filePath),
                availableSchemas
              )
            );
          }
        }
      }
    } else if (assocProp.target && !availableSchemas.includes(assocProp.target)) {
      errors.push(
        invalidAssociationTargetError(
          assocProp.target,
          buildLocation7(schema.filePath),
          availableSchemas
        )
      );
    }
    if (relation && MORPH_INVERSE_RELATIONS2.includes(relation)) {
      if (assocProp.morphName && assocProp.target) {
        const targetSchema = allSchemas[assocProp.target];
        if (targetSchema?.properties) {
          const morphProperty = targetSchema.properties[assocProp.morphName];
          if (!morphProperty) {
            errors.push(
              validationError(
                `Property '${name}' references non-existent morphName '${assocProp.morphName}' on '${assocProp.target}'`,
                buildLocation7(schema.filePath),
                `Add a MorphTo property '${assocProp.morphName}' to ${assocProp.target} schema`
              )
            );
          } else if (morphProperty.type === "Association") {
            const morphAssoc = morphProperty;
            if (morphAssoc.relation !== "MorphTo") {
              errors.push(
                validationError(
                  `Property '${name}' morphName '${assocProp.morphName}' on '${assocProp.target}' must be a MorphTo relation`,
                  buildLocation7(schema.filePath),
                  `Change ${assocProp.target}.${assocProp.morphName} relation to MorphTo`
                )
              );
            }
          }
        }
      }
    }
    if (assocProp.inversedBy && assocProp.target) {
      const targetSchema = allSchemas[assocProp.target];
      if (targetSchema?.properties) {
        const inverseProperty = targetSchema.properties[assocProp.inversedBy];
        if (!inverseProperty) {
          errors.push(
            validationError(
              `Property '${name}' references non-existent inverse property '${assocProp.inversedBy}' on '${assocProp.target}'`,
              buildLocation7(schema.filePath),
              `Add property '${assocProp.inversedBy}' to ${assocProp.target} schema`
            )
          );
        }
      }
    }
    if (assocProp.onDelete && !VALID_REFERENTIAL_ACTIONS.includes(assocProp.onDelete)) {
      errors.push(
        validationError(
          `Property '${name}' has invalid onDelete action '${assocProp.onDelete}'`,
          buildLocation7(schema.filePath),
          `Use one of: ${VALID_REFERENTIAL_ACTIONS.join(", ")}`
        )
      );
    }
    if (assocProp.onUpdate && !VALID_REFERENTIAL_ACTIONS.includes(assocProp.onUpdate)) {
      errors.push(
        validationError(
          `Property '${name}' has invalid onUpdate action '${assocProp.onUpdate}'`,
          buildLocation7(schema.filePath),
          `Use one of: ${VALID_REFERENTIAL_ACTIONS.join(", ")}`
        )
      );
    }
    if (relation === "ManyToOne" || relation === "OneToOne" && !assocProp.mappedBy) {
      const expectedFkColumn = `${toSnakeCase(name)}_id`;
      if (schema.properties[expectedFkColumn]) {
        errors.push(
          validationError(
            `Duplicate FK definition: Property '${expectedFkColumn}' conflicts with Association '${name}'`,
            buildLocation7(schema.filePath),
            `Both create the same column '${expectedFkColumn}'. Choose one approach:
  1. Use Association only (remove '${expectedFkColumn}' property) - recommended
  2. Use explicit FK only (remove '${name}' Association)`
          )
        );
      }
    }
  }
  return errors;
}
function validateOptions(schema, filePath) {
  const errors = [];
  const options = schema.options;
  if (!options) {
    return errors;
  }
  if (options.idType !== void 0) {
    if (!VALID_ID_TYPES.includes(options.idType)) {
      errors.push(
        validationError(
          `Invalid idType '${options.idType}'`,
          buildLocation7(filePath),
          `Use one of: ${VALID_ID_TYPES.join(", ")}`
        )
      );
    }
  }
  if (options.unique && schema.properties) {
    const propertyNames = Object.keys(schema.properties);
    const uniqueConstraints = Array.isArray(options.unique[0]) ? options.unique : [options.unique];
    for (const constraint of uniqueConstraints) {
      for (const column of constraint) {
        if (!propertyNames.includes(column)) {
          errors.push(
            validationError(
              `Unique constraint references non-existent property '${column}'`,
              buildLocation7(filePath),
              `Available properties: ${propertyNames.join(", ")}`
            )
          );
        }
      }
    }
  }
  if (options.indexes && schema.properties) {
    const propertyNames = Object.keys(schema.properties);
    for (const index of options.indexes) {
      const columns = typeof index === "string" ? [index] : index.columns;
      for (const column of columns) {
        if (!propertyNames.includes(column)) {
          errors.push(
            validationError(
              `Index references non-existent property '${column}'`,
              buildLocation7(filePath),
              `Available properties: ${propertyNames.join(", ")}`
            )
          );
        }
      }
    }
  }
  if (options.authenticatable) {
    if (options.authenticatableLoginIdField && schema.properties) {
      if (!schema.properties[options.authenticatableLoginIdField]) {
        errors.push(
          validationError(
            `authenticatableLoginIdField references non-existent property '${options.authenticatableLoginIdField}'`,
            buildLocation7(filePath)
          )
        );
      }
    }
    if (options.authenticatablePasswordField && schema.properties) {
      if (!schema.properties[options.authenticatablePasswordField]) {
        errors.push(
          validationError(
            `authenticatablePasswordField references non-existent property '${options.authenticatablePasswordField}'`,
            buildLocation7(filePath)
          )
        );
      }
    }
  }
  return errors;
}
function validateEnumSchema(schema, filePath) {
  const errors = [];
  if (schema.kind !== "enum") {
    return errors;
  }
  if (!schema.values || schema.values.length === 0) {
    errors.push(
      validationError(
        "Enum schema requires at least one value",
        buildLocation7(filePath),
        "Add values: [value1, value2, ...]"
      )
    );
  }
  if (schema.values) {
    const seen = /* @__PURE__ */ new Set();
    for (const value of schema.values) {
      if (seen.has(value)) {
        errors.push(
          validationError(
            `Duplicate enum value '${value}'`,
            buildLocation7(filePath)
          )
        );
      }
      seen.add(value);
    }
  }
  return errors;
}
function validatePartialSchema(schema, filePath) {
  const errors = [];
  if (schema.kind !== "partial") {
    return errors;
  }
  if (schema.priority !== void 0) {
    if (typeof schema.priority !== "number") {
      errors.push(
        validationError(
          "Partial schema priority must be a number",
          buildLocation7(filePath),
          "Example: priority: 10 (lower = higher priority, default is 50)"
        )
      );
    } else if (schema.priority < 1 || schema.priority > 100) {
      errors.push(
        validationError(
          `Partial schema priority must be between 1 and 100 (got ${schema.priority})`,
          buildLocation7(filePath),
          "Use 1-49 for high priority, 51-100 for low priority (default is 50)"
        )
      );
    }
  }
  if (!schema.properties || Object.keys(schema.properties).length === 0) {
    errors.push(
      validationError(
        "Partial schema requires at least one property to extend the target",
        buildLocation7(filePath),
        "Add properties to extend the target schema"
      )
    );
  }
  if (schema.values && schema.values.length > 0) {
    errors.push(
      validationError(
        "Partial schema cannot have values (values are for enum schemas)",
        buildLocation7(filePath),
        "Remove values or change kind to enum"
      )
    );
  }
  if (schema.options) {
    const invalidOptions = ["id", "timestamps", "softDelete", "tableName"];
    for (const opt of invalidOptions) {
      if (schema.options[opt] !== void 0) {
        errors.push(
          validationError(
            `Partial schema cannot have option '${opt}' (table options belong to the target schema)`,
            buildLocation7(filePath),
            `Remove options.${opt} - table-level options should be in the target schema`
          )
        );
      }
    }
  }
  return errors;
}
function validatePivotSchema(schema, filePath, allSchemas) {
  const errors = [];
  if (schema.kind !== "pivot") {
    return errors;
  }
  const pivotFor = schema.pivotFor;
  if (!pivotFor) {
    errors.push(
      validationError(
        "Pivot schema requires pivotFor field with two schema names",
        buildLocation7(filePath),
        "Add pivotFor: [SchemaA, SchemaB] to specify the relationship"
      )
    );
  } else if (!Array.isArray(pivotFor) || pivotFor.length !== 2) {
    errors.push(
      validationError(
        "Pivot schema pivotFor must be an array of exactly two schema names",
        buildLocation7(filePath),
        "Example: pivotFor: [User, Role]"
      )
    );
  } else {
    if (allSchemas) {
      for (const targetName of pivotFor) {
        if (!allSchemas[targetName]) {
          errors.push(
            validationError(
              `Pivot schema references unknown schema '${targetName}'`,
              buildLocation7(filePath),
              `Create schema '${targetName}' or fix the pivotFor reference`
            )
          );
        }
      }
    }
  }
  if (schema.options?.id === true) {
  }
  if (schema.values?.length) {
    errors.push(
      validationError(
        "Pivot schema cannot have values (values are for enum schemas)",
        buildLocation7(filePath),
        "Remove values or change kind to enum"
      )
    );
  }
  return errors;
}
function validateLocalizedString(fieldName, value, filePath, localeConfig, context) {
  const warnings = [];
  if (value === void 0 || !(0, import_omnify_types2.isLocaleMap)(value)) {
    return { warnings };
  }
  if (!localeConfig) {
    return { warnings };
  }
  const configuredLocales = new Set(localeConfig.locales);
  const usedLocales = Object.keys(value);
  for (const locale of usedLocales) {
    if (!configuredLocales.has(locale)) {
      const contextStr = context ? ` (property '${context}')` : "";
      warnings.push(
        validationError(
          `${fieldName}${contextStr} uses locale '${locale}' which is not in configured locales`,
          buildLocation7(filePath),
          `Configured locales: ${localeConfig.locales.join(", ")}. Add '${locale}' to your locale configuration or remove it from the schema.`
        )
      );
    }
  }
  return { warnings };
}
function validateLocalizedStrings(schema, localeConfig) {
  const warnings = [];
  const schemaDisplayNameResult = validateLocalizedString(
    "displayName",
    schema.displayName,
    schema.filePath,
    localeConfig
  );
  warnings.push(...schemaDisplayNameResult.warnings);
  if (schema.properties) {
    for (const [propName, property] of Object.entries(schema.properties)) {
      const propDisplayNameResult = validateLocalizedString(
        "displayName",
        property.displayName,
        schema.filePath,
        localeConfig,
        propName
      );
      warnings.push(...propDisplayNameResult.warnings);
      const propDescription = property.description;
      const propDescriptionResult = validateLocalizedString(
        "description",
        propDescription,
        schema.filePath,
        localeConfig,
        propName
      );
      warnings.push(...propDescriptionResult.warnings);
    }
  }
  return warnings;
}
function validateSchema(schema, options = {}) {
  const errors = [];
  const warnings = [];
  const customTypes = options.customTypes ?? [];
  const unknownSchemaFieldErrors = validateUnknownSchemaFields(schema, schema.filePath);
  errors.push(...unknownSchemaFieldErrors);
  const unknownOptionsErrors = validateUnknownOptionsFields(schema, schema.filePath);
  errors.push(...unknownOptionsErrors);
  const propertyFormatErrors = validatePropertyFormat(schema, schema.filePath);
  errors.push(...propertyFormatErrors);
  const propErrors = validateProperties(schema, schema.filePath, customTypes);
  errors.push(...propErrors);
  const optErrors = validateOptions(schema, schema.filePath);
  errors.push(...optErrors);
  if (schema.kind === "enum") {
    const enumErrors = validateEnumSchema(schema, schema.filePath);
    errors.push(...enumErrors);
  }
  if (schema.kind === "partial") {
    const partialErrors = validatePartialSchema(schema, schema.filePath);
    errors.push(...partialErrors);
  }
  if (schema.kind === "pivot") {
    const pivotErrors = validatePivotSchema(schema, schema.filePath);
    errors.push(...pivotErrors);
  }
  if (schema.titleIndex && schema.properties) {
    if (!schema.properties[schema.titleIndex]) {
      errors.push(
        validationError(
          `titleIndex references non-existent property '${schema.titleIndex}'`,
          buildLocation7(schema.filePath),
          `Available properties: ${Object.keys(schema.properties).join(", ")}`
        )
      );
    }
  }
  if (schema.properties) {
    for (const [name, property] of Object.entries(schema.properties)) {
      const propertyUnknownFields = property._unknownFields;
      if (propertyUnknownFields && propertyUnknownFields.length > 0) {
        for (const field of propertyUnknownFields) {
          errors.push(
            validationError(
              `Property '${name}' has unknown field '${field}'`,
              buildLocation7(schema.filePath),
              getSuggestionForUnknownField(field)
            )
          );
        }
      }
      const unknownFieldResult = validateUnknownFieldsDetailed(
        name,
        property,
        schema.filePath,
        options.customTypeDefinitions
      );
      errors.push(...unknownFieldResult.errors);
      warnings.push(...unknownFieldResult.warnings);
      const dbCompat = validateDbCompatibility(name, property, schema.filePath, options.databaseDriver);
      errors.push(...dbCompat.errors);
      warnings.push(...dbCompat.warnings);
      const rulesErrors = validateRules(name, property, schema.filePath);
      errors.push(...rulesErrors);
      const baseProp = property;
      if (baseProp.default !== void 0) {
        const defaultResult = validateDefaultValue(property.type, baseProp.default, baseProp);
        if (!defaultResult.valid) {
          errors.push(
            validationError(
              `Property '${name}' has invalid default value: ${defaultResult.error}`,
              buildLocation7(schema.filePath),
              property.type === "Timestamp" ? `For Timestamp type, use 'useCurrent: true' for CURRENT_TIMESTAMP behavior` : void 0
            )
          );
        }
      }
    }
  }
  const localizedStringWarnings = validateLocalizedStrings(schema, options.localeConfig);
  warnings.push(...localizedStringWarnings);
  return {
    schemaName: schema.name,
    valid: errors.length === 0,
    errors,
    warnings
  };
}
function validateSchemas(schemas, options = {}) {
  const schemaResults = [];
  const allErrors = [];
  const allWarnings = [];
  const validateAssocs = options.validateAssociations ?? true;
  for (const schema of Object.values(schemas)) {
    const result = validateSchema(schema, options);
    schemaResults.push(result);
    allErrors.push(...result.errors);
    allWarnings.push(...result.warnings);
  }
  if (validateAssocs) {
    for (const schema of Object.values(schemas)) {
      const assocErrors = validateAssociations(schema, schemas);
      allErrors.push(...assocErrors);
      const existingResult = schemaResults.find((r) => r.schemaName === schema.name);
      if (existingResult && assocErrors.length > 0) {
        const updatedResult = {
          ...existingResult,
          valid: false,
          errors: [...existingResult.errors, ...assocErrors]
        };
        const index = schemaResults.indexOf(existingResult);
        schemaResults[index] = updatedResult;
      }
    }
  }
  return {
    valid: allErrors.length === 0,
    errorCount: allErrors.length,
    warningCount: allWarnings.length,
    schemas: schemaResults,
    errors: allErrors,
    warnings: allWarnings
  };
}

// src/plugins/generator-runner.ts
var GeneratorRunner = class {
  generators = /* @__PURE__ */ new Map();
  options;
  constructor(options) {
    this.options = options;
  }
  /**
   * Register a generator.
   */
  register(generator) {
    const name = generator.definition.name;
    if (this.generators.has(name)) {
      throw new Error(`Generator "${name}" is already registered`);
    }
    this.generators.set(name, generator);
  }
  /**
   * Register multiple generators.
   */
  registerAll(generators) {
    for (const gen of generators) {
      this.register(gen);
    }
  }
  /**
   * Clear all registered generators.
   */
  clear() {
    this.generators.clear();
  }
  /**
   * Get all registered generator names.
   */
  getGeneratorNames() {
    return Array.from(this.generators.keys());
  }
  /**
   * Check if a generator is registered.
   */
  hasGenerator(name) {
    return this.generators.has(name);
  }
  /**
   * Run all generators in topological order.
   * @param schemas - The schemas to generate from
   * @param changes - Schema changes detected from lock file comparison
   */
  async runAll(schemas, changes) {
    const errors = [];
    const outputs = [];
    const outputsByGenerator = /* @__PURE__ */ new Map();
    let executionOrder;
    try {
      executionOrder = this.topologicalSort();
    } catch (error) {
      return {
        success: false,
        outputs: [],
        outputsByGenerator: /* @__PURE__ */ new Map(),
        executionOrder: [],
        errors: [{
          generatorName: "",
          message: error instanceof Error ? error.message : String(error),
          cause: error
        }]
      };
    }
    const previousOutputs = /* @__PURE__ */ new Map();
    for (const name of executionOrder) {
      const generator = this.generators.get(name);
      const { definition, pluginConfig } = generator;
      try {
        this.options.logger.debug(`Running generator: ${name}`);
        const ctx = {
          schemas,
          changes,
          pluginConfig,
          cwd: this.options.cwd,
          logger: this.options.logger,
          previousOutputs,
          customTypes: this.options.customTypes ?? /* @__PURE__ */ new Map(),
          pluginEnums: this.options.pluginEnums ?? /* @__PURE__ */ new Map(),
          localeConfig: this.options.localeConfig
        };
        const result = await definition.generate(ctx);
        const generatorOutputs = Array.isArray(result) ? result : [result];
        outputsByGenerator.set(name, generatorOutputs);
        previousOutputs.set(name, generatorOutputs);
        outputs.push(...generatorOutputs);
        this.options.logger.debug(`Generator ${name} produced ${generatorOutputs.length} outputs`);
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this.options.logger.error(`Generator ${name} failed: ${message}`);
        errors.push({
          generatorName: name,
          message,
          cause: error
        });
      }
    }
    return {
      success: errors.length === 0,
      outputs,
      outputsByGenerator,
      executionOrder,
      errors
    };
  }
  /**
   * Topological sort using Kahn's algorithm.
   * Returns generators in execution order (dependencies first).
   * Throws if circular dependencies detected.
   */
  topologicalSort() {
    const names = Array.from(this.generators.keys());
    const inDegree = /* @__PURE__ */ new Map();
    const adjacency = /* @__PURE__ */ new Map();
    for (const name of names) {
      inDegree.set(name, 0);
      adjacency.set(name, []);
    }
    for (const name of names) {
      const generator = this.generators.get(name);
      const deps = generator.definition.dependsOn ?? [];
      for (const dep of deps) {
        if (!this.generators.has(dep)) {
          throw new Error(
            `Generator "${name}" depends on "${dep}" which is not registered`
          );
        }
        adjacency.get(dep).push(name);
        inDegree.set(name, inDegree.get(name) + 1);
      }
    }
    const queue = [];
    const result = [];
    for (const [name, degree] of inDegree) {
      if (degree === 0) {
        queue.push(name);
      }
    }
    while (queue.length > 0) {
      const current = queue.shift();
      result.push(current);
      for (const neighbor of adjacency.get(current)) {
        const newDegree = inDegree.get(neighbor) - 1;
        inDegree.set(neighbor, newDegree);
        if (newDegree === 0) {
          queue.push(neighbor);
        }
      }
    }
    if (result.length !== names.length) {
      const remaining = names.filter((n) => !result.includes(n));
      throw new Error(
        `Circular dependency detected among generators: ${remaining.join(", ")}`
      );
    }
    return result;
  }
};

// src/plugins/manager.ts
var nullLogger = {
  debug: () => {
  },
  info: () => {
  },
  warn: () => {
  },
  error: () => {
  }
};
var consoleLogger = {
  debug: (msg) => console.log(`[plugin:debug] ${msg}`),
  info: (msg) => console.log(`[plugin:info] ${msg}`),
  warn: (msg) => console.warn(`[plugin:warn] ${msg}`),
  error: (msg) => console.error(`[plugin:error] ${msg}`)
};
var PluginManager = class {
  _plugins = /* @__PURE__ */ new Map();
  _types = /* @__PURE__ */ new Map();
  _enums = /* @__PURE__ */ new Map();
  _generators = /* @__PURE__ */ new Map();
  _pluginConfigs = /* @__PURE__ */ new Map();
  _cwd;
  _verbose;
  _logger;
  constructor(options = {}) {
    this._cwd = options.cwd ?? process.cwd();
    this._verbose = options.verbose ?? false;
    this._logger = options.logger ?? (this._verbose ? consoleLogger : nullLogger);
  }
  /**
   * Creates a plugin context for plugin setup.
   */
  createContext() {
    return {
      cwd: this._cwd,
      verbose: this._verbose,
      logger: this._logger
    };
  }
  /**
   * Registers a single plugin.
   * @param plugin - The plugin to register
   * @param pluginConfig - Optional configuration passed to plugin generators
   */
  async register(plugin, pluginConfig = {}) {
    const warnings = [];
    const registeredTypes = [];
    if (this._plugins.has(plugin.name)) {
      return {
        success: false,
        types: [],
        warnings: [],
        error: `Plugin '${plugin.name}' is already registered`
      };
    }
    this._logger.debug(`Registering plugin: ${plugin.name}@${plugin.version}`);
    this._pluginConfigs.set(plugin.name, pluginConfig);
    if (plugin.setup) {
      try {
        await plugin.setup(this.createContext());
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        return {
          success: false,
          types: [],
          warnings: [],
          error: `Plugin setup failed: ${message}`
        };
      }
    }
    if (plugin.types) {
      for (const typeDef of plugin.types) {
        const existing = this._types.get(typeDef.name);
        if (existing) {
          throw pluginTypeConflictError(
            typeDef.name,
            existing.pluginName,
            plugin.name
          );
        }
        const validationError2 = this.validateTypeDefinition(typeDef);
        if (validationError2) {
          warnings.push(`Type '${typeDef.name}': ${validationError2}`);
          continue;
        }
        const registeredType = {
          ...typeDef,
          pluginName: plugin.name,
          pluginVersion: plugin.version
        };
        this._types.set(typeDef.name, registeredType);
        registeredTypes.push(registeredType);
        this._logger.debug(`  Registered type: ${typeDef.name}`);
      }
    }
    if (plugin.enums) {
      for (const enumDef of plugin.enums) {
        const existing = this._enums.get(enumDef.name);
        if (existing) {
          warnings.push(
            `Enum '${enumDef.name}' already registered by another plugin`
          );
          continue;
        }
        this._enums.set(enumDef.name, enumDef);
        this._logger.debug(`  Registered enum: ${enumDef.name}`);
      }
    }
    if (plugin.generators) {
      for (const genDef of plugin.generators) {
        const existing = this._generators.get(genDef.name);
        if (existing) {
          warnings.push(
            `Generator '${genDef.name}' already registered by plugin '${existing.pluginName}'`
          );
          continue;
        }
        const registeredGenerator = {
          definition: genDef,
          pluginName: plugin.name,
          pluginVersion: plugin.version,
          pluginConfig
        };
        this._generators.set(genDef.name, registeredGenerator);
        this._logger.debug(`  Registered generator: ${genDef.name}`);
      }
    }
    this._plugins.set(plugin.name, plugin);
    const genCount = plugin.generators?.length ?? 0;
    const enumCount = plugin.enums?.length ?? 0;
    this._logger.info(
      `Plugin registered: ${plugin.name} (${registeredTypes.length} types, ${enumCount} enums, ${genCount} generators)`
    );
    return {
      success: true,
      types: registeredTypes,
      warnings
    };
  }
  /**
   * Registers multiple plugins.
   */
  async registerAll(plugins) {
    for (const plugin of plugins) {
      const result = await this.register(plugin);
      if (!result.success) {
        throw pluginError(result.error ?? "Unknown error", plugin.name);
      }
    }
  }
  /**
   * Validates a type definition.
   */
  validateTypeDefinition(typeDef) {
    if (!typeDef.name || typeDef.name.length === 0) {
      return "Type name is required";
    }
    if (typeDef.compound) {
      if (!typeDef.expand || typeDef.expand.length === 0) {
        return "Compound type must have expand definitions";
      }
      for (const field of typeDef.expand) {
        if (!field.suffix) {
          return "Expanded field must have a suffix";
        }
        const hasSql = field.sql && field.sql.sqlType;
        const hasEnumRef = "enumRef" in field && typeof field.enumRef === "string";
        if (!hasSql && !hasEnumRef) {
          return `Expanded field '${field.suffix}' must have SQL type or enumRef`;
        }
        if (!hasEnumRef && (!field.typescript || !field.typescript.type)) {
          return `Expanded field '${field.suffix}' must have TypeScript type`;
        }
      }
    } else {
      if (!typeDef.sql || !typeDef.sql.sqlType) {
        return "Non-compound type must have SQL definition";
      }
      if (!typeDef.typescript || !typeDef.typescript.type) {
        return "Non-compound type must have TypeScript type";
      }
    }
    return void 0;
  }
  /**
   * Unregisters a plugin and its types/generators.
   */
  async unregister(pluginName) {
    const plugin = this._plugins.get(pluginName);
    if (!plugin) {
      throw pluginNotFoundError(pluginName);
    }
    if (plugin.teardown) {
      try {
        await plugin.teardown();
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        this._logger.warn(`Plugin teardown failed: ${message}`);
      }
    }
    for (const [typeName, type] of this._types) {
      if (type.pluginName === pluginName) {
        this._types.delete(typeName);
      }
    }
    for (const [genName, gen] of this._generators) {
      if (gen.pluginName === pluginName) {
        this._generators.delete(genName);
      }
    }
    this._pluginConfigs.delete(pluginName);
    this._plugins.delete(pluginName);
    this._logger.info(`Plugin unregistered: ${pluginName}`);
  }
  /**
   * Gets a registered type by name.
   */
  getType(typeName) {
    return this._types.get(typeName);
  }
  /**
   * Checks if a type is registered.
   */
  hasType(typeName) {
    return this._types.has(typeName);
  }
  /**
   * Gets all registered types.
   */
  getAllTypes() {
    return this._types;
  }
  /**
   * Gets all registered type names.
   */
  getTypeNames() {
    return Array.from(this._types.keys());
  }
  /**
   * Gets a registered plugin by name.
   */
  getPlugin(pluginName) {
    return this._plugins.get(pluginName);
  }
  /**
   * Gets all registered plugins.
   */
  getAllPlugins() {
    return this._plugins;
  }
  /**
   * Gets a registered generator by name.
   */
  getGenerator(generatorName) {
    return this._generators.get(generatorName);
  }
  /**
   * Checks if a generator is registered.
   */
  hasGenerator(generatorName) {
    return this._generators.has(generatorName);
  }
  /**
   * Gets all registered generators.
   */
  getAllGenerators() {
    return this._generators;
  }
  /**
   * Gets all registered generator names.
   */
  getGeneratorNames() {
    return Array.from(this._generators.keys());
  }
  /**
   * Gets the current registry state.
   */
  getRegistry() {
    return {
      plugins: this._plugins,
      types: this._types,
      generators: this._generators
    };
  }
  /**
   * Runs all registered generators in topological order.
   * @param schemas - The schemas to generate from
   * @param changes - Schema changes detected from lock file comparison
   * @returns Result with all generated outputs
   */
  async runGenerators(schemas, changes) {
    const customTypes = /* @__PURE__ */ new Map();
    for (const [name, registeredType] of this._types) {
      const { pluginName, pluginVersion, ...typeDefinition } = registeredType;
      customTypes.set(name, typeDefinition);
    }
    const runner = new GeneratorRunner({
      cwd: this._cwd,
      logger: this._logger,
      customTypes,
      pluginEnums: this._enums
    });
    for (const gen of this._generators.values()) {
      runner.register(gen);
    }
    return runner.runAll(schemas, changes);
  }
  /**
   * Clears all registered plugins, types, and generators.
   */
  async clear() {
    for (const plugin of this._plugins.values()) {
      if (plugin.teardown) {
        try {
          await plugin.teardown();
        } catch {
        }
      }
    }
    this._plugins.clear();
    this._types.clear();
    this._enums.clear();
    this._generators.clear();
    this._pluginConfigs.clear();
    this._logger.debug("Plugin registry cleared");
  }
};
function createPluginManager(options) {
  return new PluginManager(options);
}

// src/plugins/expander.ts
function expandProperty(propertyName, property, registry) {
  const typeName = property.type;
  const registeredType = registry.types.get(typeName);
  if (!registeredType || !registeredType.compound || !registeredType.expand) {
    return [{
      originalName: propertyName,
      expandedName: propertyName,
      property,
      isCompound: false
    }];
  }
  const expanded = [];
  for (const field of registeredType.expand) {
    const expandedName = `${propertyName}${field.suffix}`;
    const expandedProperty = {
      type: "String",
      // Use String as placeholder, actual SQL type is in field.sql
      // Copy nullable from original property
      ...property.nullable !== void 0 ? { nullable: property.nullable } : {}
    };
    expanded.push({
      originalName: propertyName,
      expandedName,
      property: expandedProperty,
      isCompound: true,
      sourceType: typeName
    });
  }
  return expanded;
}
function expandSchemaProperties(schema, registry) {
  const expandedMap = /* @__PURE__ */ new Map();
  if (!schema.properties) {
    return expandedMap;
  }
  for (const [propName, property] of Object.entries(schema.properties)) {
    const expanded = expandProperty(propName, property, registry);
    expandedMap.set(propName, expanded);
  }
  return expandedMap;
}
function expandSchema(schema, registry) {
  if (!schema.properties || schema.kind === "enum") {
    return schema;
  }
  const expandedProperties = {};
  let hasExpansion = false;
  for (const [propName, property] of Object.entries(schema.properties)) {
    const expanded = expandProperty(propName, property, registry);
    const firstExpanded = expanded[0];
    if (expanded.length === 1 && firstExpanded && !firstExpanded.isCompound) {
      expandedProperties[propName] = property;
    } else {
      hasExpansion = true;
      for (const exp of expanded) {
        expandedProperties[exp.expandedName] = exp.property;
      }
    }
  }
  if (!hasExpansion) {
    return schema;
  }
  return {
    ...schema,
    properties: expandedProperties
  };
}
function expandSchemas(schemas, registry) {
  const expanded = {};
  for (const [name, schema] of Object.entries(schemas)) {
    expanded[name] = expandSchema(schema, registry);
  }
  return expanded;
}
function getTypeInfo(typeName, registry) {
  return registry.types.get(typeName);
}
function isCompoundType(typeName, registry) {
  const type = registry.types.get(typeName);
  return type?.compound === true;
}
function getCustomTypeNames(registry) {
  return Array.from(registry.types.keys());
}

// src/api/omnify.ts
var import_node_path = require("path");

// src/api/metadata.ts
function isAssociation(prop) {
  return prop.type === "Association";
}
function getSchemaMetadata(schema) {
  const propertyNames = [];
  const associationNames = [];
  if (schema.properties) {
    for (const [name, prop] of Object.entries(schema.properties)) {
      if (isAssociation(prop)) {
        associationNames.push(name);
      } else {
        propertyNames.push(name);
      }
    }
  }
  const kind = schema.kind === "enum" ? "enum" : "entity";
  const result = {
    name: schema.name,
    kind,
    filePath: schema.filePath,
    propertyNames,
    associationNames,
    hasTimestamps: schema.options?.timestamps ?? false,
    hasSoftDelete: schema.options?.softDelete ?? false,
    idType: schema.options?.idType ?? "BigInt"
  };
  if (schema.displayName !== void 0) {
    result.displayName = schema.displayName;
  }
  if (schema.group !== void 0) {
    result.group = schema.group;
  }
  return result;
}
function getPropertyMetadata(name, property, registry) {
  if (isAssociation(property)) {
    return {
      name,
      type: "Association",
      nullable: false,
      unique: false,
      hasDefault: false,
      isPluginType: false
    };
  }
  const isPluginType = registry?.types.has(property.type) ?? false;
  const pluginType = registry?.types.get(property.type);
  const result = {
    name,
    type: property.type,
    nullable: property.nullable ?? false,
    unique: property.unique ?? false,
    hasDefault: "default" in property && property.default !== void 0,
    isPluginType
  };
  if ("default" in property && property.default !== void 0) {
    result.defaultValue = property.default;
  }
  if (pluginType?.pluginName !== void 0) {
    result.pluginName = pluginType.pluginName;
  }
  return result;
}
function getAssociationMetadata(name, association) {
  const result = {
    name,
    relation: association.relation
  };
  if (association.target !== void 0) {
    result.target = association.target;
  }
  if (association.targets !== void 0) {
    result.targets = association.targets;
  }
  if (association.morphName !== void 0) {
    result.morphName = association.morphName;
  }
  if (association.inversedBy !== void 0) {
    result.inversedBy = association.inversedBy;
  }
  if (association.mappedBy !== void 0) {
    result.mappedBy = association.mappedBy;
  }
  if (association.onDelete !== void 0) {
    result.onDelete = association.onDelete;
  }
  if (association.onUpdate !== void 0) {
    result.onUpdate = association.onUpdate;
  }
  return result;
}
function introspectSchema(schema, registry) {
  const metadata = getSchemaMetadata(schema);
  const properties = [];
  const associations = [];
  if (schema.properties) {
    for (const [name, prop] of Object.entries(schema.properties)) {
      if (isAssociation(prop)) {
        associations.push(getAssociationMetadata(name, prop));
      } else {
        properties.push(getPropertyMetadata(name, prop, registry));
      }
    }
  }
  return {
    metadata,
    properties,
    associations,
    schema
  };
}
function introspectSchemas(schemas, registry) {
  const result = /* @__PURE__ */ new Map();
  for (const [name, schema] of Object.entries(schemas)) {
    result.set(name, introspectSchema(schema, registry));
  }
  return result;
}
function getSchemaNames(schemas) {
  return Object.keys(schemas);
}
function getSchemasByKind(schemas, kind) {
  return Object.values(schemas).filter((schema) => {
    const schemaKind = schema.kind === "enum" ? "enum" : "entity";
    return schemaKind === kind;
  });
}
function getEntitySchemas(schemas) {
  return getSchemasByKind(schemas, "entity");
}
function getEnumSchemas(schemas) {
  return getSchemasByKind(schemas, "enum");
}
function getSchemasByGroup(schemas, group) {
  return Object.values(schemas).filter((schema) => schema.group === group);
}
function getGroups(schemas) {
  const groups = /* @__PURE__ */ new Set();
  for (const schema of Object.values(schemas)) {
    if (schema.group) {
      groups.add(schema.group);
    }
  }
  return Array.from(groups).sort();
}
function getSchemaAssociations(schema) {
  if (!schema.properties) return [];
  const associations = [];
  for (const prop of Object.values(schema.properties)) {
    if (isAssociation(prop)) {
      associations.push(prop);
    }
  }
  return associations;
}
function findReferencingSchemas(schemas, targetName) {
  const result = [];
  for (const schema of Object.values(schemas)) {
    const associations = getSchemaAssociations(schema);
    for (const association of associations) {
      if (association.target === targetName) {
        result.push(schema);
        break;
      }
    }
  }
  return result;
}
function findReferencedSchemas(schemas, sourceName) {
  const source = schemas[sourceName];
  if (!source) return [];
  const associations = getSchemaAssociations(source);
  const targetNames = new Set(associations.map((a) => a.target));
  return Object.values(schemas).filter((s) => targetNames.has(s.name));
}
function getRelationshipGraph(schemas) {
  const graph = /* @__PURE__ */ new Map();
  for (const schema of Object.values(schemas)) {
    const targets = [];
    const associations = getSchemaAssociations(schema);
    for (const association of associations) {
      if (association.targets) {
        for (const target of association.targets) {
          if (!targets.includes(target)) {
            targets.push(target);
          }
        }
      } else if (association.target && !targets.includes(association.target)) {
        targets.push(association.target);
      }
    }
    graph.set(schema.name, targets);
  }
  return graph;
}
function hasCircularReferences(schemas) {
  const graph = getRelationshipGraph(schemas);
  const visited = /* @__PURE__ */ new Set();
  const recursionStack = /* @__PURE__ */ new Set();
  function hasCycle(node) {
    if (recursionStack.has(node)) return true;
    if (visited.has(node)) return false;
    visited.add(node);
    recursionStack.add(node);
    const neighbors = graph.get(node) ?? [];
    for (const neighbor of neighbors) {
      if (hasCycle(neighbor)) return true;
    }
    recursionStack.delete(node);
    return false;
  }
  for (const schemaName of graph.keys()) {
    if (hasCycle(schemaName)) return true;
  }
  return false;
}
function getTopologicalOrder(schemas) {
  const graph = getRelationshipGraph(schemas);
  const result = [];
  const visited = /* @__PURE__ */ new Set();
  function visit(node) {
    if (visited.has(node)) return;
    visited.add(node);
    const neighbors = graph.get(node) ?? [];
    for (const neighbor of neighbors) {
      visit(neighbor);
    }
    result.push(node);
  }
  for (const schemaName of graph.keys()) {
    visit(schemaName);
  }
  return result;
}

// src/api/omnify.ts
var nullLogger2 = {
  debug: () => {
  },
  info: () => {
  },
  warn: () => {
  },
  error: () => {
  }
};
var consoleLogger2 = {
  debug: (msg, ...args) => console.debug(`[omnify] ${msg}`, ...args),
  info: (msg, ...args) => console.info(`[omnify] ${msg}`, ...args),
  warn: (msg, ...args) => console.warn(`[omnify] ${msg}`, ...args),
  error: (msg, ...args) => console.error(`[omnify] ${msg}`, ...args)
};
var Omnify = class {
  options;
  logger;
  pluginManager;
  schemas = null;
  loaded = false;
  constructor(options) {
    this.options = {
      ...options,
      schemaDir: (0, import_node_path.resolve)(options.schemaDir)
    };
    this.logger = options.logger ?? (options.verbose ? consoleLogger2 : nullLogger2);
    this.pluginManager = createPluginManager({ logger: this.logger });
  }
  /**
   * Registers plugins with the plugin manager.
   */
  async registerPlugins(plugins) {
    for (const plugin of plugins) {
      this.logger.debug(`Registering plugin: ${plugin.name}`);
      const result = await this.pluginManager.register(plugin);
      if (!result.success) {
        throw new Error(`Failed to register plugin ${plugin.name}: ${result.error}`);
      }
      if (result.warnings.length > 0) {
        for (const warning of result.warnings) {
          this.logger.warn(warning);
        }
      }
    }
  }
  /**
   * Loads and validates schemas from the configured directory.
   */
  async load() {
    this.logger.info(`Loading schemas from: ${this.options.schemaDir}`);
    if (this.options.plugins?.length) {
      await this.registerPlugins(this.options.plugins);
    }
    const errors = [];
    const warnings = [];
    try {
      const schemas = await loadSchemas(this.options.schemaDir, {
        recursive: true
      });
      this.logger.debug(`Loaded ${Object.keys(schemas).length} schemas`);
      const customTypeNames = Array.from(this.pluginManager.getRegistry().types.keys());
      const validationResult = validateSchemas(schemas, {
        customTypes: customTypeNames
      });
      for (const error of validationResult.errors) {
        const schemaError = {
          file: error.file ?? "unknown",
          message: error.message
        };
        if (error.line !== void 0) {
          schemaError.line = error.line;
        }
        if (error.suggestion !== void 0) {
          schemaError.suggestion = error.suggestion;
        }
        errors.push(schemaError);
      }
      for (const warning of validationResult.warnings) {
        warnings.push({
          file: warning.file ?? "unknown",
          message: warning.message
        });
      }
      if (validationResult.valid) {
        this.schemas = schemas;
        this.loaded = true;
      }
      return {
        success: validationResult.valid,
        schemas,
        errors,
        warnings
      };
    } catch (error) {
      if (error instanceof OmnifyError) {
        const schemaError = {
          file: error.file ?? "unknown",
          message: error.message
        };
        if (error.line !== void 0) {
          schemaError.line = error.line;
        }
        if (error.suggestion !== void 0) {
          schemaError.suggestion = error.suggestion;
        }
        errors.push(schemaError);
      } else {
        errors.push({
          file: "unknown",
          message: error instanceof Error ? error.message : String(error)
        });
      }
      return {
        success: false,
        schemas: {},
        errors,
        warnings
      };
    }
  }
  /**
   * Gets loaded schemas. Throws if not loaded.
   */
  getSchemas() {
    if (!this.loaded || !this.schemas) {
      throw new Error("Schemas not loaded. Call load() first.");
    }
    return this.schemas;
  }
  /**
   * Gets a single schema by name.
   */
  getSchema(name) {
    const schemas = this.getSchemas();
    const schema = schemas[name];
    if (!schema) return void 0;
    return introspectSchema(schema, this.pluginManager.getRegistry());
  }
  /**
   * Gets all schema names.
   */
  getSchemaNames() {
    return getSchemaNames(this.getSchemas());
  }
  /**
   * Gets entity schemas (non-enum).
   */
  getEntitySchemas() {
    const schemas = getEntitySchemas(this.getSchemas());
    return schemas.map(
      (s) => introspectSchema(s, this.pluginManager.getRegistry())
    );
  }
  /**
   * Gets enum schemas.
   */
  getEnumSchemas() {
    const schemas = getEnumSchemas(this.getSchemas());
    return schemas.map(
      (s) => introspectSchema(s, this.pluginManager.getRegistry())
    );
  }
  /**
   * Gets schemas by group.
   */
  getSchemasByGroup(group) {
    const schemas = getSchemasByGroup(this.getSchemas(), group);
    return schemas.map(
      (s) => introspectSchema(s, this.pluginManager.getRegistry())
    );
  }
  /**
   * Gets all unique group names.
   */
  getGroups() {
    return getGroups(this.getSchemas());
  }
  /**
   * Introspects a specific schema.
   */
  introspect(name) {
    return this.getSchema(name);
  }
  /**
   * Introspects all schemas.
   */
  introspectAll() {
    return introspectSchemas(this.getSchemas(), this.pluginManager.getRegistry());
  }
  /**
   * Finds schemas that reference a target schema.
   */
  findReferencingSchemas(targetName) {
    const schemas = findReferencingSchemas(this.getSchemas(), targetName);
    return schemas.map(
      (s) => introspectSchema(s, this.pluginManager.getRegistry())
    );
  }
  /**
   * Finds schemas referenced by a source schema.
   */
  findReferencedSchemas(sourceName) {
    const schemas = findReferencedSchemas(this.getSchemas(), sourceName);
    return schemas.map(
      (s) => introspectSchema(s, this.pluginManager.getRegistry())
    );
  }
  /**
   * Checks if schemas have circular references.
   */
  hasCircularReferences() {
    return hasCircularReferences(this.getSchemas());
  }
  /**
   * Gets topological order of schemas (dependencies first).
   */
  getTopologicalOrder() {
    return getTopologicalOrder(this.getSchemas());
  }
  /**
   * Gets the plugin registry.
   */
  getPluginRegistry() {
    return this.pluginManager.getRegistry();
  }
  /**
   * Checks if a type is registered (from plugin).
   */
  hasType(typeName) {
    return this.pluginManager.hasType(typeName);
  }
  /**
   * Gets custom type names from all registered plugins.
   */
  getCustomTypeNames() {
    return Array.from(this.pluginManager.getRegistry().types.keys());
  }
};
function createOmnify(options) {
  return new Omnify(options);
}

// src/history/version-store.ts
var import_promises = require("fs/promises");
var import_path = require("path");
var import_js_yaml2 = __toESM(require("js-yaml"), 1);
var OMNIFY_DIR = ".omnify";
var VERSIONS_DIR = "versions";
function deepEqual(a, b) {
  if (a === b) return true;
  if (a === null || b === null) return a === b;
  if (typeof a !== typeof b) return false;
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) {
      if (!deepEqual(a[i], b[i])) return false;
    }
    return true;
  }
  if (typeof a === "object" && typeof b === "object") {
    const aObj = a;
    const bObj = b;
    const aKeys = Object.keys(aObj);
    const bKeys = Object.keys(bObj);
    if (aKeys.length !== bKeys.length) return false;
    for (const key of aKeys) {
      if (!Object.prototype.hasOwnProperty.call(bObj, key)) return false;
      if (!deepEqual(aObj[key], bObj[key])) return false;
    }
    return true;
  }
  return false;
}
var CURRENT_FILE = "current.lock";
var VERSION_FILE_PATTERN = /^(\d{4})(?:_(.+))?\.lock$/;
function formatVersionNumber(version) {
  return version.toString().padStart(4, "0");
}
function parseVersionFilename(filename) {
  const match = filename.match(VERSION_FILE_PATTERN);
  if (!match || !match[1]) return null;
  const result = {
    version: parseInt(match[1], 10)
  };
  if (match[2] !== void 0) {
    result.name = match[2];
  }
  return result;
}
function generateVersionFilename(version, migration) {
  const versionStr = formatVersionNumber(version);
  if (migration) {
    const name = migration.replace(/^\d+_/, "").replace(/\.sql$/, "");
    return `${versionStr}_${name}.lock`;
  }
  return `${versionStr}.lock`;
}
async function dirExists(path2) {
  try {
    await (0, import_promises.access)(path2);
    return true;
  } catch {
    return false;
  }
}
var VersionStore = class {
  omnifyDir;
  versionsDir;
  maxVersions;
  constructor(config) {
    this.omnifyDir = (0, import_path.join)(config.baseDir, OMNIFY_DIR);
    this.versionsDir = (0, import_path.join)(this.omnifyDir, VERSIONS_DIR);
    this.maxVersions = config.maxVersions ?? 0;
  }
  /**
   * Initialize the version store directory structure.
   */
  async initialize() {
    await (0, import_promises.mkdir)(this.versionsDir, { recursive: true });
  }
  /**
   * Get the path to the versions directory.
   */
  getVersionsDir() {
    return this.versionsDir;
  }
  /**
   * Get the path to a specific version file.
   */
  getVersionPath(version, migration) {
    const filename = generateVersionFilename(version, migration);
    return (0, import_path.join)(this.versionsDir, filename);
  }
  /**
   * List all available versions.
   */
  async listVersions() {
    if (!await dirExists(this.versionsDir)) {
      return [];
    }
    const files = await (0, import_promises.readdir)(this.versionsDir);
    const versions = [];
    for (const file of files) {
      const parsed = parseVersionFilename(file);
      if (!parsed) continue;
      try {
        const filePath = (0, import_path.join)(this.versionsDir, file);
        const content = await (0, import_promises.readFile)(filePath, "utf-8");
        const versionFile = import_js_yaml2.default.load(content);
        const summary = {
          version: versionFile.version,
          timestamp: versionFile.timestamp,
          ...versionFile.migration !== void 0 && { migration: versionFile.migration },
          ...versionFile.description !== void 0 && { description: versionFile.description },
          schemaCount: Object.keys(versionFile.snapshot).length,
          changeCount: versionFile.changes.length
        };
        versions.push(summary);
      } catch {
      }
    }
    return versions.sort((a, b) => a.version - b.version);
  }
  /**
   * Get the latest version number.
   */
  async getLatestVersion() {
    const versions = await this.listVersions();
    if (versions.length === 0) return 0;
    const lastVersion = versions[versions.length - 1];
    return lastVersion?.version ?? 0;
  }
  /**
   * Read a specific version file.
   */
  async readVersion(version) {
    if (!await dirExists(this.versionsDir)) {
      return null;
    }
    const files = await (0, import_promises.readdir)(this.versionsDir);
    for (const file of files) {
      const parsed = parseVersionFilename(file);
      if (parsed?.version === version) {
        const filePath = (0, import_path.join)(this.versionsDir, file);
        const content = await (0, import_promises.readFile)(filePath, "utf-8");
        return import_js_yaml2.default.load(content);
      }
    }
    return null;
  }
  /**
   * Read the latest version file.
   */
  async readLatestVersion() {
    const latestVersion = await this.getLatestVersion();
    if (latestVersion === 0) return null;
    return this.readVersion(latestVersion);
  }
  /**
   * Create a new version.
   */
  async createVersion(snapshot, changes, options) {
    await this.initialize();
    const latestVersion = await this.getLatestVersion();
    const newVersion = latestVersion + 1;
    const versionFile = {
      version: newVersion,
      timestamp: (/* @__PURE__ */ new Date()).toISOString(),
      driver: options.driver,
      ...options.migration !== void 0 && { migration: options.migration },
      ...options.description !== void 0 && { description: options.description },
      changes,
      snapshot
    };
    const filePath = this.getVersionPath(newVersion, options.migration);
    const content = import_js_yaml2.default.dump(versionFile, {
      lineWidth: -1,
      // Disable line wrapping
      noRefs: true,
      quotingType: '"'
    });
    await (0, import_promises.writeFile)(filePath, content, "utf-8");
    await this.updateCurrentLink(versionFile);
    if (this.maxVersions > 0) {
      await this.cleanupOldVersions();
    }
    return versionFile;
  }
  /**
   * Update the current.lock file to point to latest version.
   */
  async updateCurrentLink(versionFile) {
    const currentPath = (0, import_path.join)(this.omnifyDir, CURRENT_FILE);
    const content = import_js_yaml2.default.dump(versionFile, {
      lineWidth: -1,
      noRefs: true,
      quotingType: '"'
    });
    await (0, import_promises.writeFile)(currentPath, content, "utf-8");
  }
  /**
   * Cleanup old versions beyond maxVersions limit.
   */
  async cleanupOldVersions() {
    const versions = await this.listVersions();
    if (versions.length <= this.maxVersions) return;
    const toDelete = versions.slice(0, versions.length - this.maxVersions);
    for (const v of toDelete) {
      const files = await (0, import_promises.readdir)(this.versionsDir);
      for (const file of files) {
        const parsed = parseVersionFilename(file);
        if (parsed?.version === v.version) {
          await (0, import_promises.rm)((0, import_path.join)(this.versionsDir, file));
          break;
        }
      }
    }
  }
  /**
   * Get diff between two versions.
   */
  async diffVersions(fromVersion, toVersion) {
    const fromFile = await this.readVersion(fromVersion);
    const toFile = await this.readVersion(toVersion);
    if (!fromFile || !toFile) return null;
    const allChanges = [];
    if (fromVersion < toVersion) {
      for (let v = fromVersion + 1; v <= toVersion; v++) {
        const vFile = await this.readVersion(v);
        if (vFile) {
          allChanges.push(...vFile.changes);
        }
      }
    } else {
      const changes = this.computeSnapshotDiff(fromFile.snapshot, toFile.snapshot);
      allChanges.push(...changes);
    }
    return {
      fromVersion,
      toVersion,
      changes: allChanges
    };
  }
  /**
   * Compute changes between two snapshots.
   */
  computeSnapshotDiff(from, to) {
    const changes = [];
    const fromNames = new Set(Object.keys(from));
    const toNames = new Set(Object.keys(to));
    for (const name of toNames) {
      if (!fromNames.has(name)) {
        changes.push({ action: "schema_added", schema: name });
      }
    }
    for (const name of fromNames) {
      if (!toNames.has(name)) {
        changes.push({ action: "schema_removed", schema: name });
      }
    }
    for (const name of fromNames) {
      if (!toNames.has(name)) continue;
      const fromSchema = from[name];
      const toSchema = to[name];
      if (!fromSchema || !toSchema) continue;
      const fromProps = fromSchema.properties ?? {};
      const toProps = toSchema.properties ?? {};
      const fromPropNames = new Set(Object.keys(fromProps));
      const toPropNames = new Set(Object.keys(toProps));
      for (const prop of toPropNames) {
        if (!fromPropNames.has(prop)) {
          changes.push({
            action: "property_added",
            schema: name,
            property: prop,
            to: toProps[prop]
          });
        }
      }
      for (const prop of fromPropNames) {
        if (!toPropNames.has(prop)) {
          changes.push({
            action: "property_removed",
            schema: name,
            property: prop,
            from: fromProps[prop]
          });
        }
      }
      for (const prop of fromPropNames) {
        if (!toPropNames.has(prop)) continue;
        if (!deepEqual(fromProps[prop], toProps[prop])) {
          changes.push({
            action: "property_modified",
            schema: name,
            property: prop,
            from: fromProps[prop],
            to: toProps[prop]
          });
        }
      }
      const fromOpts = fromSchema.options ?? {};
      const toOpts = toSchema.options ?? {};
      const optionDefaults = {
        id: true,
        idType: "BigInt",
        timestamps: true,
        softDelete: false,
        tableName: void 0,
        // no default
        translations: false,
        authenticatable: false
      };
      const getNormalizedOption = (opts, key) => {
        const value = opts[key];
        if (value === void 0) {
          return optionDefaults[key];
        }
        return value;
      };
      const simpleOptions = ["timestamps", "softDelete", "id", "idType", "tableName", "translations", "authenticatable"];
      for (const opt of simpleOptions) {
        const fromVal = getNormalizedOption(fromOpts, opt);
        const toVal = getNormalizedOption(toOpts, opt);
        if (!deepEqual(fromVal, toVal)) {
          changes.push({
            action: "option_changed",
            schema: name,
            property: opt,
            from: fromOpts[opt],
            // Keep original value for display
            to: toOpts[opt]
          });
        }
      }
      const fromIndexes = fromOpts.indexes ?? [];
      const toIndexes = toOpts.indexes ?? [];
      const columnsMatch = (a, b) => {
        if (a.length !== b.length) return false;
        return a.every((col, i) => col === b[i]);
      };
      const matchedFromIndexes = /* @__PURE__ */ new Set();
      for (const toIdx of toIndexes) {
        const fromIndex = fromIndexes.findIndex(
          (fromIdx, i) => !matchedFromIndexes.has(i) && columnsMatch(fromIdx.columns, toIdx.columns)
        );
        if (fromIndex === -1) {
          changes.push({
            action: "index_added",
            schema: name,
            to: toIdx
          });
        } else {
          matchedFromIndexes.add(fromIndex);
          const fromIdx = fromIndexes[fromIndex];
          if (!deepEqual(fromIdx, toIdx)) {
            changes.push({
              action: "index_modified",
              schema: name,
              from: fromIdx,
              to: toIdx
            });
          }
        }
      }
      for (let i = 0; i < fromIndexes.length; i++) {
        if (!matchedFromIndexes.has(i)) {
          changes.push({
            action: "index_removed",
            schema: name,
            from: fromIndexes[i]
          });
        }
      }
    }
    return changes;
  }
  /**
   * Get snapshot at a specific version (for rollback).
   */
  async getSnapshotAt(version) {
    const versionFile = await this.readVersion(version);
    return versionFile?.snapshot ?? null;
  }
};
function createVersionStore(config) {
  return new VersionStore(config);
}

// src/ai-guides/adapters/cursor.ts
function replacePlaceholders(content, placeholders) {
  let result = content;
  for (const [key, value] of Object.entries(placeholders)) {
    result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, "g"), value);
  }
  return result;
}
var cursorAdapter = {
  name: "cursor",
  outputDir: ".cursor/rules/omnify",
  transform(content, rule, placeholders) {
    const target = rule.targets.cursor;
    let transformedContent = replacePlaceholders(content, placeholders);
    if (transformedContent.startsWith("---")) {
      return transformedContent;
    }
    const description = target?.description || "";
    const globs = target?.globs || [];
    const alwaysApply = target?.alwaysApply ?? false;
    const frontmatter = `---
description: "${description}"
globs: ${JSON.stringify(globs)}
alwaysApply: ${alwaysApply}
---

`;
    return frontmatter + transformedContent;
  },
  getFilename(rule) {
    const target = rule.targets.cursor;
    if (target?.filename) {
      return target.filename;
    }
    return `${rule.id}.mdc`;
  },
  isEnabled(rule) {
    const target = rule.targets.cursor;
    return target?.enabled ?? false;
  },
  getOutputPath(rule) {
    const filename = this.getFilename(rule);
    return filename;
  }
};

// src/ai-guides/adapters/claude.ts
function replacePlaceholders2(content, placeholders) {
  let result = content;
  for (const [key, value] of Object.entries(placeholders)) {
    result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, "g"), value);
  }
  return result;
}
var claudeAdapter = {
  name: "claude",
  outputDir: ".claude/omnify",
  transform(content, rule, placeholders) {
    return replacePlaceholders2(content, placeholders);
  },
  getFilename(rule) {
    const target = rule.targets.claude;
    if (target?.filename) {
      return target.filename;
    }
    return `${rule.id}.md`;
  },
  isEnabled(rule) {
    const target = rule.targets.claude;
    return target?.enabled ?? false;
  },
  getOutputPath(rule) {
    const target = rule.targets.claude;
    const filename = this.getFilename(rule);
    const subdir = target?.subdir || rule.category;
    if (subdir) {
      return `${subdir}/${filename}`;
    }
    return filename;
  }
};

// src/ai-guides/adapters/antigravity.ts
function replacePlaceholders3(content, placeholders) {
  let result = content;
  for (const [key, value] of Object.entries(placeholders)) {
    result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, "g"), value);
  }
  return result;
}
var antigravityAdapter = {
  name: "antigravity",
  outputDir: ".agent/rules/omnify",
  transform(content, rule, placeholders) {
    const target = rule.targets.antigravity;
    let transformedContent = replacePlaceholders3(content, placeholders);
    if (transformedContent.startsWith("---")) {
      const endIndex = transformedContent.indexOf("---", 3);
      if (endIndex !== -1) {
        const existingFrontmatter = transformedContent.substring(3, endIndex).trim();
        const bodyContent = transformedContent.substring(endIndex + 3).trim();
        const antigravityFrontmatter = buildAntigravityFrontmatter(rule, target, existingFrontmatter);
        return `---
${antigravityFrontmatter}---

${bodyContent}`;
      }
    }
    const frontmatter = buildAntigravityFrontmatter(rule, target);
    return `---
${frontmatter}---

${transformedContent}`;
  },
  getFilename(rule) {
    const target = rule.targets.antigravity;
    if (target?.filename) {
      return target.filename;
    }
    return `${rule.id}.md`;
  },
  isEnabled(rule) {
    const target = rule.targets.antigravity;
    return target?.enabled ?? false;
  },
  getOutputPath(rule) {
    const filename = this.getFilename(rule);
    return filename;
  }
};
function buildAntigravityFrontmatter(rule, target, existingFrontmatter) {
  const lines = [];
  lines.push(`id: ${rule.id}`);
  const description = target?.description || extractDescription(existingFrontmatter) || rule.id;
  lines.push(`description: "${description}"`);
  lines.push(`category: ${rule.category || "general"}`);
  const priority = target?.priority || "medium";
  lines.push(`priority: ${priority}`);
  const globs = target?.globs || extractGlobs(existingFrontmatter) || [];
  if (globs.length > 0) {
    lines.push(`globs:`);
    for (const glob of globs) {
      lines.push(`  - "${glob}"`);
    }
  }
  const tags = target?.tags || inferTags(rule);
  if (tags.length > 0) {
    lines.push(`tags:`);
    for (const tag of tags) {
      lines.push(`  - ${tag}`);
    }
  }
  return lines.join("\n") + "\n";
}
function extractDescription(frontmatter) {
  if (!frontmatter) return void 0;
  const match = frontmatter.match(/description:\s*["']?([^"'\n]+)["']?/);
  return match?.[1];
}
function extractGlobs(frontmatter) {
  if (!frontmatter) return [];
  const match = frontmatter.match(/globs:\s*\[([^\]]+)\]/);
  if (match) {
    return match[1].split(",").map((g) => g.trim().replace(/["']/g, ""));
  }
  return [];
}
function inferTags(rule) {
  const tags = [];
  if (rule.category) {
    const parts = rule.category.split("/");
    tags.push(...parts.filter((p) => p !== "guides"));
  }
  if (rule.id.includes("laravel")) tags.push("laravel");
  if (rule.id.includes("react")) tags.push("react");
  if (rule.id.includes("schema")) tags.push("schema");
  if (rule.id.includes("omnify")) tags.push("omnify");
  return [...new Set(tags)];
}

// src/ai-guides/adapters/index.ts
var allAdapters = [
  cursorAdapter,
  claudeAdapter,
  antigravityAdapter
];
function getAdapter(name) {
  return allAdapters.find((a) => a.name === name);
}
function getAdapters(names) {
  if (!names || names.length === 0) {
    return allAdapters;
  }
  return allAdapters.filter((a) => names.includes(a.name));
}

// src/ai-guides/generator.ts
var import_node_fs = require("fs");
var import_node_path2 = require("path");
var import_node_url = require("url");
var import_yaml = require("yaml");
var import_meta = {};
var __filename = (0, import_node_url.fileURLToPath)(import_meta.url);
var __dirname = (0, import_node_path2.dirname)(__filename);
function getKnowledgeDir() {
  const possiblePaths = [
    // Dev: src内で実行している場合
    (0, import_node_path2.resolve)(__dirname, "knowledge"),
    // Dist: dist/から実行、src/ai-guides/knowledge
    (0, import_node_path2.resolve)(__dirname, "../src/ai-guides/knowledge"),
    // Installed package: node_modules内
    (0, import_node_path2.resolve)(__dirname, "../knowledge")
  ];
  for (const path2 of possiblePaths) {
    if ((0, import_node_fs.existsSync)(path2)) {
      return path2;
    }
  }
  throw new Error(`AI guides knowledge directory not found. Tried: ${possiblePaths.join(", ")}`);
}
function getConfigDir() {
  const possiblePaths = [
    // Dev: src内で実行している場合
    (0, import_node_path2.resolve)(__dirname, "config"),
    // Dist: dist/から実行、src/ai-guides/config
    (0, import_node_path2.resolve)(__dirname, "../src/ai-guides/config"),
    // Installed package: node_modules内
    (0, import_node_path2.resolve)(__dirname, "../config")
  ];
  for (const path2 of possiblePaths) {
    if ((0, import_node_fs.existsSync)(path2)) {
      return path2;
    }
  }
  throw new Error(`AI guides config directory not found. Tried: ${possiblePaths.join(", ")}`);
}
function loadRulesConfig() {
  const configDir = getConfigDir();
  const rulesPath = (0, import_node_path2.join)(configDir, "rules.yaml");
  if (!(0, import_node_fs.existsSync)(rulesPath)) {
    throw new Error(`Rules config not found: ${rulesPath}`);
  }
  const content = (0, import_node_fs.readFileSync)(rulesPath, "utf-8");
  return (0, import_yaml.parse)(content);
}
function loadKnowledgeFile(source) {
  const knowledgeDir = getKnowledgeDir();
  const filePath = (0, import_node_path2.join)(knowledgeDir, source);
  if (!(0, import_node_fs.existsSync)(filePath)) {
    throw new Error(`Knowledge file not found: ${filePath}`);
  }
  return (0, import_node_fs.readFileSync)(filePath, "utf-8");
}
function replacePlaceholders4(content, placeholders) {
  let result = content;
  for (const [key, value] of Object.entries(placeholders)) {
    result = result.replace(new RegExp(`\\{\\{${key}\\}\\}`, "g"), value);
  }
  return result;
}
function writeOutputFile(filePath, content, dryRun) {
  if (dryRun) {
    console.log(`[DRY RUN] Would write: ${filePath}`);
    return;
  }
  const dir = (0, import_node_path2.dirname)(filePath);
  if (!(0, import_node_fs.existsSync)(dir)) {
    (0, import_node_fs.mkdirSync)(dir, { recursive: true });
  }
  (0, import_node_fs.writeFileSync)(filePath, content);
}
function generateAIGuides(rootDir, options = {}) {
  const config = loadRulesConfig();
  const knowledgeDir = getKnowledgeDir();
  const adapters = getAdapters(options.adapters);
  const dryRun = options.dryRun ?? false;
  const placeholders = {
    ...config.placeholders,
    ...options.placeholders
  };
  const result = {
    counts: {},
    files: []
  };
  for (const adapter of adapters) {
    result.counts[adapter.name] = 0;
  }
  for (const rule of config.guides) {
    try {
      const content = loadKnowledgeFile(rule.source);
      for (const adapter of adapters) {
        if (!adapter.isEnabled(rule)) {
          continue;
        }
        const transformed = adapter.transform(content, rule, placeholders);
        const outputPath = adapter.getOutputPath(rule);
        const fullPath = (0, import_node_path2.resolve)(rootDir, adapter.outputDir, outputPath);
        writeOutputFile(fullPath, transformed, dryRun);
        result.files.push(fullPath);
        result.counts[adapter.name]++;
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      result.errors = result.errors || [];
      result.errors.push(`Error processing ${rule.id}: ${message}`);
    }
  }
  const cursorAdapter2 = adapters.find((a) => a.name === "cursor");
  if (cursorAdapter2 && config.cursorRules) {
    for (const rule of config.cursorRules) {
      try {
        const content = loadKnowledgeFile(rule.source);
        const transformed = replacePlaceholders4(content, placeholders);
        const filename = (0, import_node_path2.basename)(rule.source).replace(".mdc.stub", ".mdc").replace(".md.stub", ".md");
        const fullPath = (0, import_node_path2.resolve)(rootDir, cursorAdapter2.outputDir, filename);
        writeOutputFile(fullPath, transformed, dryRun);
        result.files.push(fullPath);
        result.counts[cursorAdapter2.name]++;
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        result.errors = result.errors || [];
        result.errors.push(`Error processing cursor rule ${rule.source}: ${message}`);
      }
    }
  }
  const claudeAdapter2 = adapters.find((a) => a.name === "claude");
  if (claudeAdapter2 && config.claudeRules) {
    for (const rule of config.claudeRules) {
      try {
        const content = loadKnowledgeFile(rule.source);
        const strippedContent = stripFrontmatter(content);
        const transformed = replacePlaceholders4(strippedContent, placeholders);
        const filename = (0, import_node_path2.basename)(rule.source).replace(".mdc.stub", ".mdc").replace(".md.stub", ".md").replace(".mdc", ".md");
        const fullPath = (0, import_node_path2.resolve)(rootDir, ".claude/rules/omnify", filename);
        writeOutputFile(fullPath, transformed, dryRun);
        result.files.push(fullPath);
        result.counts[claudeAdapter2.name]++;
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        result.errors = result.errors || [];
        result.errors.push(`Error processing claude rule ${rule.source}: ${message}`);
      }
    }
  }
  const antigravityAdapterInstance = adapters.find((a) => a.name === "antigravity");
  if (antigravityAdapterInstance && config.antigravityRules) {
    for (const rule of config.antigravityRules) {
      try {
        const content = loadKnowledgeFile(rule.source);
        const transformed = transformForAntigravity(content, rule, placeholders);
        const filename = (0, import_node_path2.basename)(rule.source).replace(".mdc.stub", ".mdc").replace(".md.stub", ".md").replace(".mdc", ".md");
        const fullPath = (0, import_node_path2.resolve)(rootDir, antigravityAdapterInstance.outputDir, filename);
        writeOutputFile(fullPath, transformed, dryRun);
        result.files.push(fullPath);
        result.counts[antigravityAdapterInstance.name]++;
      } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        result.errors = result.errors || [];
        result.errors.push(`Error processing antigravity rule ${rule.source}: ${message}`);
      }
    }
  }
  return result;
}
function transformForAntigravity(content, rule, placeholders) {
  let transformed = replacePlaceholders4(content, placeholders);
  if (transformed.startsWith("---")) {
    const endIndex = transformed.indexOf("---", 3);
    if (endIndex !== -1) {
      const existingFrontmatter = transformed.substring(3, endIndex).trim();
      const bodyContent = transformed.substring(endIndex + 3).trim();
      const id = (0, import_node_path2.basename)(rule.source).replace(".mdc.stub", "").replace(".md.stub", "").replace(".mdc", "").replace(".md", "");
      const description = extractYamlValue(existingFrontmatter, "description") || id;
      const globs = extractYamlArray(existingFrontmatter, "globs");
      const priority = rule.priority || "medium";
      const tags = rule.tags || [];
      const lines = [
        `id: ${id}`,
        `description: "${description}"`,
        `priority: ${priority}`
      ];
      if (globs.length > 0) {
        lines.push("globs:");
        for (const glob of globs) {
          lines.push(`  - "${glob}"`);
        }
      }
      if (tags.length > 0) {
        lines.push("tags:");
        for (const tag of tags) {
          lines.push(`  - ${tag}`);
        }
      }
      return `---
${lines.join("\n")}
---

${bodyContent}`;
    }
  }
  return transformed;
}
function extractYamlValue(yaml3, key) {
  const match = yaml3.match(new RegExp(`${key}:\\s*["']?([^"'\\n]+)["']?`));
  return match?.[1]?.trim();
}
function extractYamlArray(yaml3, key) {
  const match = yaml3.match(new RegExp(`${key}:\\s*\\[([^\\]]+)\\]`));
  if (match) {
    return match[1].split(",").map((g) => g.trim().replace(/["']/g, ""));
  }
  return [];
}
function stripFrontmatter(content) {
  if (!content.startsWith("---")) {
    return content;
  }
  const endIndex = content.indexOf("---", 3);
  if (endIndex === -1) {
    return content;
  }
  return content.substring(endIndex + 3).trim();
}
function shouldGenerateAIGuides(rootDir) {
  const claudeDir = (0, import_node_path2.resolve)(rootDir, ".claude/omnify/guides");
  const cursorDir = (0, import_node_path2.resolve)(rootDir, ".cursor/rules/omnify");
  if (!(0, import_node_fs.existsSync)(claudeDir) || !(0, import_node_fs.existsSync)(cursorDir)) {
    return true;
  }
  try {
    const claudeFiles = (0, import_node_fs.readdirSync)(claudeDir, { recursive: true });
    const cursorFiles = (0, import_node_fs.readdirSync)(cursorDir);
    return claudeFiles.length === 0 || cursorFiles.length === 0;
  } catch {
    return true;
  }
}
function getAvailableAdapters() {
  return getAdapters().map((a) => a.name);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  FILE_SCHEMA_NAME,
  Omnify,
  OmnifyError,
  PluginManager,
  VersionStore,
  allAdapters,
  antigravityAdapter,
  atlasError,
  atlasNotFoundError,
  circularReferenceError,
  claudeAdapter,
  configError,
  configNotFoundError,
  createFileLoadedSchema,
  createFileSchemaDefinition,
  createOmnify,
  createPluginManager,
  createVersionStore,
  cursorAdapter,
  duplicateSchemaError,
  ensureFileSchema,
  err,
  expandProperty,
  expandSchema,
  expandSchemaProperties,
  expandSchemas,
  fileNameToSchemaName,
  findReferencedSchemas,
  findReferencingSchemas,
  formatError,
  formatErrorPlain,
  formatErrorSummary,
  generateAIGuides,
  generateFileSchemaYaml,
  generationError,
  getAdapter,
  getAdapters,
  getAssociationMetadata,
  getAvailableAdapters,
  getCustomTypeNames,
  getEntitySchemas,
  getEnumSchemas,
  getExitCode,
  getGroups,
  getPropertyMetadata,
  getRelationshipGraph,
  getSchemaMetadata,
  getSchemaNames,
  getSchemasByGroup,
  getSchemasByKind,
  getTopologicalOrder,
  getTypeInfo,
  hasCircularReferences,
  internalError,
  introspectSchema,
  introspectSchemas,
  invalidAssociationTargetError,
  invalidConfigError,
  invalidPropertyTypeError,
  isCompoundType,
  jsonSyntaxError,
  loadSchema,
  loadSchemas,
  mergePartialSchemas,
  missingConfigFieldError,
  missingFieldError,
  notImplementedError,
  ok,
  outputWriteError,
  parseJsonSchema,
  parseYamlSchema,
  pluginError,
  pluginNotFoundError,
  pluginTypeConflictError,
  schemaNotFoundError,
  schemaParseError,
  schemasHaveFileProperties,
  shouldGenerateAIGuides,
  validateAssociations,
  validateDefaultValue,
  validateEnumSchema,
  validateOptions,
  validateProperties,
  validatePropertyType,
  validateSchema,
  validateSchemas,
  validationError,
  yamlSyntaxError
});
//# sourceMappingURL=index.cjs.map