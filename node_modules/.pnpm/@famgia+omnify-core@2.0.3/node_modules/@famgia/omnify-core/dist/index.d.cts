import { ErrorCode, ErrorLocation, OmnifyErrorInfo, LoadedSchema, SchemaCollection, SchemaDefinition, CustomTypeDefinition, LocaleConfig, PropertyDefinition, PluginLogger, GeneratorDefinition, OmnifyPlugin, GeneratorOutput, SchemaChange, OmnifyConfig, LocalizedString, AssociationDefinition } from '@famgia/omnify-types';
export { AssociationRelation, CustomTypeDefinition, DatabaseConfig, ErrorCode, ErrorLocation, LoadedSchema, OmnifyConfig, OmnifyErrorInfo, OmnifyPlugin, OutputConfig, PropertyDefinition, PropertyType, Result, SchemaCollection, SchemaDefinition, SchemaOptions, err, ok } from '@famgia/omnify-types';

/**
 * @famgia/omnify-core - OmnifyError Class
 *
 * Base error class for all omnify errors with file:line:message:suggestion format.
 */

/**
 * Base error class for omnify-schema.
 * Provides consistent error formatting with source location and suggestions.
 *
 * @example
 * ```typescript
 * throw new OmnifyError(
 *   "Invalid property type 'Stringg'",
 *   'E201',
 *   { file: 'schemas/User.yaml', line: 15, column: 10 },
 *   "Did you mean 'String'?"
 * );
 * ```
 */
declare class OmnifyError extends Error {
    /** Error code (e.g., 'E201') */
    readonly code: ErrorCode;
    /** Source location where the error occurred */
    readonly location?: ErrorLocation;
    /** Suggested fix for the error */
    readonly suggestion?: string;
    /** Additional context or details */
    readonly details?: Record<string, unknown>;
    /** Original error if this wraps another error */
    readonly cause?: Error;
    constructor(message: string, code: ErrorCode, location?: ErrorLocation, suggestion?: string, options?: {
        details?: Record<string, unknown>;
        cause?: Error;
    });
    /**
     * Creates an OmnifyError from an OmnifyErrorInfo object.
     */
    static fromInfo(info: OmnifyErrorInfo): OmnifyError;
    /**
     * Wraps an unknown error as an OmnifyError.
     * Useful for catching and re-throwing with context.
     */
    static wrap(error: unknown, code?: ErrorCode, location?: ErrorLocation): OmnifyError;
    /**
     * Converts to OmnifyErrorInfo for serialization.
     */
    toInfo(): OmnifyErrorInfo;
    /**
     * Returns a formatted string representation.
     * Format: "Error [CODE]: message\n  --> file:line:column"
     */
    toString(): string;
    /**
     * Returns the file path from location, if available.
     */
    get file(): string | undefined;
    /**
     * Returns the line number from location, if available.
     */
    get line(): number | undefined;
    /**
     * Returns the column number from location, if available.
     */
    get column(): number | undefined;
}

/**
 * @famgia/omnify-core - Error Formatter
 *
 * Formats errors for CLI output with optional ANSI colors.
 */

/**
 * Options for error formatting.
 */
interface FormatOptions {
    /** Enable ANSI color codes */
    readonly color?: boolean;
    /** Show source context lines */
    readonly showContext?: boolean;
    /** Number of context lines to show */
    readonly contextLines?: number;
    /** Source file content (for showing context) */
    readonly sourceContent?: string;
}
/**
 * Formats an OmnifyError for CLI output.
 *
 * @example Output:
 * ```
 * error[E201]: Invalid property type 'Stringg'
 *   --> schemas/User.yaml:15:10
 *    |
 * 15 |     type: Stringg
 *    |           ^^^^^^^ Did you mean 'String'?
 *    |
 *   = suggestion: Use one of: String, Int, Boolean, Text, ...
 * ```
 */
declare function formatError(error: OmnifyError, options?: FormatOptions): string;
/**
 * Formats multiple errors as a summary.
 */
declare function formatErrorSummary(errors: readonly OmnifyError[], options?: FormatOptions): string;
/**
 * Formats an error for plain text output (no colors).
 */
declare function formatErrorPlain(error: OmnifyError): string;
/**
 * Gets the exit code for an error based on its code category.
 */
declare function getExitCode(error: OmnifyError): number;

/**
 * @famgia/omnify-core - Error Factory Functions
 *
 * Convenient factory functions for creating common error types.
 */

/**
 * Creates a configuration error.
 */
declare function configError(message: string, code?: ErrorCode, suggestion?: string): OmnifyError;
/**
 * Config file not found error.
 */
declare function configNotFoundError(configPath: string): OmnifyError;
/**
 * Invalid config format error.
 */
declare function invalidConfigError(message: string, configPath: string): OmnifyError;
/**
 * Missing required config field error.
 */
declare function missingConfigFieldError(field: string, configPath: string): OmnifyError;
/**
 * Creates a schema parsing error.
 */
declare function schemaParseError(message: string, location: ErrorLocation, suggestion?: string): OmnifyError;
/**
 * Schema file not found error.
 */
declare function schemaNotFoundError(schemaPath: string): OmnifyError;
/**
 * Invalid YAML syntax error.
 */
declare function yamlSyntaxError(message: string, file: string, line?: number, column?: number): OmnifyError;
/**
 * Invalid JSON syntax error.
 */
declare function jsonSyntaxError(message: string, file: string, line?: number, column?: number): OmnifyError;
/**
 * Creates a schema validation error.
 */
declare function validationError(message: string, location: ErrorLocation, suggestion?: string): OmnifyError;
/**
 * Invalid property type error.
 */
declare function invalidPropertyTypeError(typeName: string, location: ErrorLocation, validTypes?: readonly string[]): OmnifyError;
/**
 * Missing required field error.
 */
declare function missingFieldError(field: string, location: ErrorLocation): OmnifyError;
/**
 * Invalid association target error.
 */
declare function invalidAssociationTargetError(target: string, location: ErrorLocation, availableSchemas?: readonly string[]): OmnifyError;
/**
 * Circular reference error.
 */
declare function circularReferenceError(path: readonly string[], location: ErrorLocation): OmnifyError;
/**
 * Duplicate schema name error.
 */
declare function duplicateSchemaError(name: string, location: ErrorLocation, existingLocation?: ErrorLocation): OmnifyError;
/**
 * Creates a plugin error.
 */
declare function pluginError(message: string, pluginName: string, cause?: Error): OmnifyError;
/**
 * Plugin not found error.
 */
declare function pluginNotFoundError(pluginName: string): OmnifyError;
/**
 * Plugin type conflict error.
 */
declare function pluginTypeConflictError(typeName: string, pluginA: string, pluginB: string): OmnifyError;
/**
 * Creates an Atlas error.
 */
declare function atlasError(message: string, cause?: Error): OmnifyError;
/**
 * Atlas CLI not found error.
 */
declare function atlasNotFoundError(): OmnifyError;
/**
 * Creates a generation error.
 */
declare function generationError(message: string, outputPath?: string, cause?: Error): OmnifyError;
/**
 * Output write error.
 */
declare function outputWriteError(outputPath: string, cause?: Error): OmnifyError;
/**
 * Creates an internal/unexpected error.
 */
declare function internalError(message: string, cause?: Error): OmnifyError;
/**
 * Not implemented error.
 */
declare function notImplementedError(feature: string): OmnifyError;

/**
 * @famgia/omnify-core - Schema Loader
 *
 * Load and parse YAML/JSON schema files into internal representation.
 */

/**
 * Options for loading schemas.
 */
interface LoadSchemaOptions {
    /** Base directory for calculating relative paths */
    readonly baseDir?: string;
}
/**
 * Options for loading a directory of schemas.
 */
interface LoadSchemasOptions {
    /** File extensions to include (default: ['.yaml', '.yml']) */
    readonly extensions?: readonly string[];
    /** Whether to load recursively from subdirectories (default: true) */
    readonly recursive?: boolean;
    /** Skip partial schema resolution (default: false) - use mergePartialSchemas later */
    readonly skipPartialResolution?: boolean;
}
/**
 * Converts a file name to a schema name (PascalCase).
 * Preserves original casing if already PascalCase.
 *
 * @example
 * fileNameToSchemaName('user-profile.yaml') // 'UserProfile'
 * fileNameToSchemaName('User.yaml') // 'User'
 * fileNameToSchemaName('ExportJob.yaml') // 'ExportJob' (preserved)
 * fileNameToSchemaName('order_item.yml') // 'OrderItem'
 */
declare function fileNameToSchemaName(fileName: string): string;
/**
 * Parses YAML content into a SchemaDefinition.
 *
 * @param content - Raw YAML content
 * @param filePath - File path for error reporting
 * @returns Parsed schema definition
 * @throws OmnifyError if YAML is invalid
 */
declare function parseYamlSchema(content: string, filePath: string): SchemaDefinition;
/**
 * Parses JSON content into a SchemaDefinition.
 *
 * @param content - Raw JSON content
 * @param filePath - File path for error reporting
 * @returns Parsed schema definition
 * @throws OmnifyError if JSON is invalid
 */
declare function parseJsonSchema(content: string, filePath: string): SchemaDefinition;
/**
 * Loads a single schema file.
 * Supports both YAML (.yaml, .yml) and JSON (.json) formats.
 *
 * @param filePath - Path to the schema file
 * @param options - Loading options
 * @returns Loaded schema with metadata
 * @throws OmnifyError if file not found or invalid syntax
 */
declare function loadSchema(filePath: string, options?: LoadSchemaOptions): Promise<LoadedSchema>;
/**
 * Loads all schemas from a directory.
 *
 * @param directoryPath - Path to the schemas directory
 * @param options - Loading options
 * @returns Collection of loaded schemas indexed by name
 * @throws OmnifyError if duplicate schema names or invalid files
 */
declare function loadSchemas(directoryPath: string, options?: LoadSchemasOptions): Promise<SchemaCollection>;
/**
 * Merges partial schemas into their target schemas.
 * Call this after combining schemas from multiple sources.
 *
 * @param schemas - Collection of regular schemas
 * @param partials - Array of partial schemas to merge (optional, extracted from schemas if not provided)
 * @returns Schema collection with partials merged into targets
 */
declare function mergePartialSchemas(schemas: Record<string, LoadedSchema>, partials?: LoadedSchema[]): SchemaCollection;
/**
 * The reserved name for the File schema (polymorphic file storage).
 */
declare const FILE_SCHEMA_NAME = "File";
/**
 * Checks if any schema in the collection has File type properties.
 */
declare function schemasHaveFileProperties(schemas: SchemaCollection): boolean;
/**
 * Creates the File schema definition for polymorphic file storage.
 * This schema represents files stored with morphOne/morphMany relationships.
 */
declare function createFileSchemaDefinition(): SchemaDefinition;
/**
 * Creates a LoadedSchema for the File schema.
 * Used when auto-generating File schema in memory.
 */
declare function createFileLoadedSchema(schemasDir: string): LoadedSchema;
/**
 * Generates YAML content for File.yaml schema.
 * Can be written to disk for user customization.
 */
declare function generateFileSchemaYaml(): string;
/**
 * Ensures File schema exists when File type is used.
 * Returns the schema collection with File schema added if needed.
 *
 * @param schemas - Existing schema collection
 * @param schemasDir - Directory where schemas are stored
 * @param autoCreate - If true, creates File.yaml on disk; if false, adds in-memory only
 * @returns Updated schema collection
 */
declare function ensureFileSchema(schemas: SchemaCollection, schemasDir: string, autoCreate?: boolean): Promise<SchemaCollection>;

/**
 * @famgia/omnify-core - Validation Types
 *
 * Types for schema validation results.
 */

/**
 * Validation result for a single schema.
 */
interface SchemaValidationResult {
    /** Schema name */
    readonly schemaName: string;
    /** Whether validation passed */
    readonly valid: boolean;
    /** Validation errors (if any) */
    readonly errors: readonly OmnifyError[];
    /** Validation warnings (if any) */
    readonly warnings: readonly OmnifyError[];
}
/**
 * Validation result for a collection of schemas.
 */
interface ValidationResult {
    /** Whether all schemas are valid */
    readonly valid: boolean;
    /** Total error count */
    readonly errorCount: number;
    /** Total warning count */
    readonly warningCount: number;
    /** Results per schema */
    readonly schemas: readonly SchemaValidationResult[];
    /** All errors across all schemas */
    readonly errors: readonly OmnifyError[];
    /** All warnings across all schemas */
    readonly warnings: readonly OmnifyError[];
}
/**
 * Supported database drivers.
 */
type DatabaseDriver = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';
/**
 * Options for schema validation.
 */
interface ValidationOptions {
    /** Whether to treat warnings as errors */
    readonly strict?: boolean;
    /**
     * Custom type names registered by plugins.
     * @deprecated Use customTypeDefinitions for full validation support
     */
    readonly customTypes?: readonly string[];
    /**
     * Full custom type definitions from plugins.
     * Provides validFields for proper field validation.
     */
    readonly customTypeDefinitions?: ReadonlyMap<string, CustomTypeDefinition>;
    /** Whether to validate associations (requires all schemas) */
    readonly validateAssociations?: boolean;
    /** Database driver for compatibility checking */
    readonly databaseDriver?: DatabaseDriver;
    /**
     * Locale configuration for validating localized strings.
     * When provided, warns if displayName/description uses locales not in the configured list.
     */
    readonly localeConfig?: LocaleConfig;
}

/**
 * Validates a property type.
 */
declare function validatePropertyType(propertyName: string, property: PropertyDefinition, filePath: string, customTypes?: readonly string[]): OmnifyError[];
/**
 * Validates all properties in a schema.
 */
declare function validateProperties(schema: SchemaDefinition, filePath: string, customTypes?: readonly string[]): OmnifyError[];
/**
 * Validates associations in a schema against available schemas.
 */
declare function validateAssociations(schema: LoadedSchema, allSchemas: SchemaCollection): OmnifyError[];
/**
 * Validates schema options.
 */
declare function validateOptions(schema: SchemaDefinition, filePath: string): OmnifyError[];
/**
 * Validates an enum schema.
 */
declare function validateEnumSchema(schema: SchemaDefinition, filePath: string): OmnifyError[];
/**
 * Validates a single schema.
 */
declare function validateSchema(schema: LoadedSchema, options?: ValidationOptions): SchemaValidationResult;
/**
 * Validates a collection of schemas.
 */
declare function validateSchemas(schemas: SchemaCollection, options?: ValidationOptions): ValidationResult;

/**
 * @famgia/omnify-core - Property Type Definition Base
 *
 * Base interface for all property type definitions.
 */

/**
 * Result of default value validation.
 */
interface DefaultValueValidationResult {
    /** Whether the value is valid */
    readonly valid: boolean;
    /** Error message if invalid */
    readonly error?: string;
}

/**
 * Validate a default value for a given type.
 *
 * @param typeName - The type name (e.g., 'Int', 'String', 'Enum')
 * @param value - The default value to validate
 * @param property - Optional property definition for context (needed for Enum/Select)
 * @returns Validation result with valid flag and optional error message
 */
declare function validateDefaultValue(typeName: string, value: unknown, property?: {
    enum?: readonly string[];
    options?: unknown[];
}): {
    valid: boolean;
    error?: string;
};

/**
 * @famgia/omnify-core - Plugin Types
 *
 * Internal types for plugin management.
 */

/**
 * Registered type with source plugin information.
 */
interface RegisteredType extends CustomTypeDefinition {
    /** Plugin that provided this type */
    readonly pluginName: string;
    /** Plugin version */
    readonly pluginVersion: string;
}
/**
 * Registered generator with source plugin information.
 */
interface RegisteredGenerator {
    /** Generator definition */
    readonly definition: GeneratorDefinition;
    /** Plugin that provided this generator */
    readonly pluginName: string;
    /** Plugin version */
    readonly pluginVersion: string;
    /** Plugin-specific configuration */
    readonly pluginConfig: Record<string, unknown>;
}
/**
 * Plugin registry state.
 */
interface PluginRegistry {
    /** Registered plugins */
    readonly plugins: ReadonlyMap<string, OmnifyPlugin>;
    /** Registered custom types */
    readonly types: ReadonlyMap<string, RegisteredType>;
    /** Registered generators */
    readonly generators: ReadonlyMap<string, RegisteredGenerator>;
}
/**
 * Plugin manager options.
 */
interface PluginManagerOptions {
    /** Current working directory */
    cwd?: string;
    /** Enable verbose logging */
    verbose?: boolean;
    /** Custom logger */
    logger?: PluginLogger;
}
/**
 * Result of plugin registration.
 */
interface PluginRegistrationResult {
    /** Whether registration was successful */
    success: boolean;
    /** Registered types */
    types: readonly RegisteredType[];
    /** Any warnings during registration */
    warnings: readonly string[];
    /** Error if registration failed */
    error?: string;
}

/**
 * @famgia/omnify-core - Generator Runner
 *
 * Executes generators in topological order based on dependencies (DAG).
 */

/**
 * Result of running all generators.
 */
interface GeneratorRunResult {
    /** Whether all generators succeeded */
    success: boolean;
    /** All generated outputs */
    outputs: GeneratorOutput[];
    /** Outputs grouped by generator name */
    outputsByGenerator: ReadonlyMap<string, GeneratorOutput[]>;
    /** Execution order (topological) */
    executionOrder: string[];
    /** Errors if any */
    errors: GeneratorError[];
}
/**
 * Error from generator execution.
 */
interface GeneratorError {
    /** Generator name */
    generatorName: string;
    /** Error message */
    message: string;
    /** Original error */
    cause?: unknown;
}

/**
 * @famgia/omnify-core - Plugin Manager
 *
 * Manages plugin registration and type resolution.
 */

/**
 * Plugin Manager class for managing plugin lifecycle.
 */
declare class PluginManager {
    private readonly _plugins;
    private readonly _types;
    private readonly _enums;
    private readonly _generators;
    private readonly _pluginConfigs;
    private readonly _cwd;
    private readonly _verbose;
    private readonly _logger;
    constructor(options?: PluginManagerOptions);
    /**
     * Creates a plugin context for plugin setup.
     */
    private createContext;
    /**
     * Registers a single plugin.
     * @param plugin - The plugin to register
     * @param pluginConfig - Optional configuration passed to plugin generators
     */
    register(plugin: OmnifyPlugin, pluginConfig?: Record<string, unknown>): Promise<PluginRegistrationResult>;
    /**
     * Registers multiple plugins.
     */
    registerAll(plugins: readonly OmnifyPlugin[]): Promise<void>;
    /**
     * Validates a type definition.
     */
    private validateTypeDefinition;
    /**
     * Unregisters a plugin and its types/generators.
     */
    unregister(pluginName: string): Promise<void>;
    /**
     * Gets a registered type by name.
     */
    getType(typeName: string): RegisteredType | undefined;
    /**
     * Checks if a type is registered.
     */
    hasType(typeName: string): boolean;
    /**
     * Gets all registered types.
     */
    getAllTypes(): ReadonlyMap<string, RegisteredType>;
    /**
     * Gets all registered type names.
     */
    getTypeNames(): readonly string[];
    /**
     * Gets a registered plugin by name.
     */
    getPlugin(pluginName: string): OmnifyPlugin | undefined;
    /**
     * Gets all registered plugins.
     */
    getAllPlugins(): ReadonlyMap<string, OmnifyPlugin>;
    /**
     * Gets a registered generator by name.
     */
    getGenerator(generatorName: string): RegisteredGenerator | undefined;
    /**
     * Checks if a generator is registered.
     */
    hasGenerator(generatorName: string): boolean;
    /**
     * Gets all registered generators.
     */
    getAllGenerators(): ReadonlyMap<string, RegisteredGenerator>;
    /**
     * Gets all registered generator names.
     */
    getGeneratorNames(): readonly string[];
    /**
     * Gets the current registry state.
     */
    getRegistry(): PluginRegistry;
    /**
     * Runs all registered generators in topological order.
     * @param schemas - The schemas to generate from
     * @param changes - Schema changes detected from lock file comparison
     * @returns Result with all generated outputs
     */
    runGenerators(schemas: SchemaCollection, changes?: readonly SchemaChange[]): Promise<GeneratorRunResult>;
    /**
     * Clears all registered plugins, types, and generators.
     */
    clear(): Promise<void>;
}
/**
 * Creates a new plugin manager instance.
 */
declare function createPluginManager(options?: PluginManagerOptions): PluginManager;

/**
 * @famgia/omnify-core - Compound Type Expander
 *
 * Expands compound types into multiple fields.
 */

/**
 * Expanded property with original property name.
 */
interface ExpandedProperty {
    /** Original property name */
    originalName: string;
    /** Expanded column name (originalName + suffix) */
    expandedName: string;
    /** The expanded field definition */
    property: PropertyDefinition;
    /** Whether this is from a compound type */
    isCompound: boolean;
    /** Source type name if from plugin */
    sourceType?: string;
}
/**
 * Expands a single property if it's a compound type.
 */
declare function expandProperty(propertyName: string, property: PropertyDefinition, registry: PluginRegistry): ExpandedProperty[];
/**
 * Expands all compound types in a schema's properties.
 */
declare function expandSchemaProperties(schema: LoadedSchema, registry: PluginRegistry): Map<string, ExpandedProperty[]>;
/**
 * Creates a new schema with compound types expanded.
 */
declare function expandSchema(schema: LoadedSchema, registry: PluginRegistry): LoadedSchema;
/**
 * Expands compound types in all schemas.
 */
declare function expandSchemas(schemas: SchemaCollection, registry: PluginRegistry): SchemaCollection;
/**
 * Gets the registered type info for a property type.
 */
declare function getTypeInfo(typeName: string, registry: PluginRegistry): RegisteredType | undefined;
/**
 * Checks if a type is a compound type.
 */
declare function isCompoundType(typeName: string, registry: PluginRegistry): boolean;
/**
 * Gets all custom type names from the registry.
 */
declare function getCustomTypeNames(registry: PluginRegistry): string[];

/**
 * @famgia/omnify-core - Programmatic API Types
 */

/**
 * Migration file definition (matches @famgia/omnify-laravel).
 */
interface MigrationFile {
    /** File path */
    path: string;
    /** Migration class name */
    className: string;
    /** Table name */
    tableName: string;
    /** File content */
    content: string;
    /** Operation type */
    operation: 'create' | 'alter' | 'drop';
}
/**
 * TypeScript file definition (matches @famgia/omnify-laravel).
 */
interface TypeScriptFile {
    /** File path */
    path: string;
    /** File content */
    content: string;
}
/**
 * Lock file definition (matches @famgia/omnify-atlas).
 */
interface LockFileInfo {
    /** Lock file version */
    version: number;
    /** Last updated timestamp */
    updatedAt: string;
    /** Schema hashes */
    schemas: Record<string, string>;
}
/**
 * Diff result definition (matches @famgia/omnify-atlas).
 */
interface DiffResultInfo {
    /** Whether there are changes */
    hasChanges: boolean;
    /** SQL statements */
    statements: string[];
    /** Summary text */
    summary: string;
}
/**
 * Options for the Omnify programmatic API.
 */
interface OmnifyOptions {
    /** Schema directory path */
    schemaDir: string;
    /** Configuration object or path to config file */
    config?: Partial<OmnifyConfig> | string;
    /** Plugins to register */
    plugins?: OmnifyPlugin[];
    /** Development database URL for Atlas */
    devUrl?: string;
    /** Enable verbose logging */
    verbose?: boolean;
    /** Custom logger */
    logger?: OmnifyLogger;
}
/**
 * Logger interface for programmatic API.
 */
interface OmnifyLogger {
    debug: (message: string, ...args: unknown[]) => void;
    info: (message: string, ...args: unknown[]) => void;
    warn: (message: string, ...args: unknown[]) => void;
    error: (message: string, ...args: unknown[]) => void;
}
/**
 * Result of loading schemas.
 */
interface LoadResult {
    /** Whether loading was successful */
    success: boolean;
    /** Loaded schemas */
    schemas: SchemaCollection;
    /** Validation errors if any */
    errors: SchemaError[];
    /** Validation warnings */
    warnings: SchemaWarning[];
}
/**
 * Schema error with location info.
 */
interface SchemaError {
    /** File path */
    file: string;
    /** Line number if available */
    line?: number;
    /** Error message */
    message: string;
    /** Suggested fix */
    suggestion?: string;
}
/**
 * Schema warning.
 */
interface SchemaWarning {
    /** File path */
    file: string;
    /** Warning message */
    message: string;
}
/**
 * Result of diff operation.
 */
interface DiffOperationResult {
    /** Whether diff was successful */
    success: boolean;
    /** Whether there are changes */
    hasChanges: boolean;
    /** Parsed diff result */
    diff: DiffResultInfo | null;
    /** SQL statements */
    sql: string[];
    /** Human-readable summary */
    summary: string;
    /** Errors if any */
    errors: SchemaError[];
}
/**
 * Options for generation.
 */
interface GenerateOptions {
    /** Output directory for Laravel migrations */
    laravelOutput?: string;
    /** Output directory for TypeScript types */
    typescriptOutput?: string;
    /** Whether to update the lock file */
    updateLockFile?: boolean;
    /** Whether to skip TypeScript generation */
    skipTypeScript?: boolean;
    /** Whether to skip Laravel generation */
    skipLaravel?: boolean;
    /** Dry run - don't write files */
    dryRun?: boolean;
}
/**
 * Result of generation operation.
 */
interface GenerateResult {
    /** Whether generation was successful */
    success: boolean;
    /** Generated Laravel migration files */
    migrations: MigrationFile[];
    /** Generated TypeScript files */
    typescript: TypeScriptFile[];
    /** Updated lock file */
    lockFile: LockFileInfo | null;
    /** Errors if any */
    errors: SchemaError[];
    /** Files that would be written (in dry run) or were written */
    files: GeneratedFile[];
}
/**
 * Generated file info.
 */
interface GeneratedFile {
    /** File path */
    path: string;
    /** File content */
    content: string;
    /** File type */
    type: 'migration' | 'typescript' | 'lock';
}
/**
 * Schema metadata for introspection.
 */
interface SchemaMetadata {
    /** Schema name */
    name: string;
    /** Display name (supports multi-language) */
    displayName?: LocalizedString;
    /** Group name */
    group?: string;
    /** Schema kind */
    kind: 'entity' | 'enum';
    /** File path */
    filePath: string;
    /** Property names */
    propertyNames: string[];
    /** Association names */
    associationNames: string[];
    /** Has timestamps */
    hasTimestamps: boolean;
    /** Has soft delete */
    hasSoftDelete: boolean;
    /** ID column type */
    idType: string;
}
/**
 * Property metadata.
 */
interface PropertyMetadata {
    /** Property name */
    name: string;
    /** Property type */
    type: string;
    /** Is nullable */
    nullable: boolean;
    /** Is unique */
    unique: boolean;
    /** Has default value */
    hasDefault: boolean;
    /** Default value */
    defaultValue?: unknown;
    /** Is from plugin */
    isPluginType: boolean;
    /** Plugin name if from plugin */
    pluginName?: string;
}
/**
 * Association metadata.
 */
interface AssociationMetadata {
    /** Association name */
    name: string;
    /** Relation type */
    relation: 'OneToOne' | 'OneToMany' | 'ManyToOne' | 'ManyToMany' | 'MorphTo' | 'MorphOne' | 'MorphMany' | 'MorphToMany' | 'MorphedByMany';
    /** Target schema (for standard and inverse polymorphic relations) */
    target?: string;
    /** Target schemas (for MorphTo) */
    targets?: readonly string[];
    /** Polymorphic name (for MorphOne/MorphMany/MorphedByMany) */
    morphName?: string;
    /** Inverse side */
    inversedBy?: string;
    /** Owning side */
    mappedBy?: string;
    /** On delete action */
    onDelete?: string;
    /** On update action */
    onUpdate?: string;
}
/**
 * Full schema introspection result.
 */
interface SchemaIntrospection {
    /** Schema metadata */
    metadata: SchemaMetadata;
    /** Properties */
    properties: PropertyMetadata[];
    /** Associations */
    associations: AssociationMetadata[];
    /** Raw schema */
    schema: LoadedSchema;
}

/**
 * @famgia/omnify-core - Omnify Programmatic API
 *
 * Main entry point for using omnify-schema programmatically.
 */

/**
 * Main Omnify API class for programmatic usage.
 *
 * @example
 * ```typescript
 * import { Omnify } from '@famgia/omnify-core';
 *
 * const omnify = new Omnify({
 *   schemaDir: './schemas',
 *   plugins: [japanTypesPlugin],
 * });
 *
 * // Load and validate schemas
 * const { schemas, errors } = await omnify.load();
 *
 * // Get schema metadata
 * const users = omnify.getSchema('User');
 *
 * // Introspect schema
 * const introspection = omnify.introspect('User');
 * ```
 */
declare class Omnify {
    private readonly options;
    private readonly logger;
    private readonly pluginManager;
    private schemas;
    private loaded;
    constructor(options: OmnifyOptions);
    /**
     * Registers plugins with the plugin manager.
     */
    registerPlugins(plugins: OmnifyPlugin[]): Promise<void>;
    /**
     * Loads and validates schemas from the configured directory.
     */
    load(): Promise<LoadResult>;
    /**
     * Gets loaded schemas. Throws if not loaded.
     */
    getSchemas(): SchemaCollection;
    /**
     * Gets a single schema by name.
     */
    getSchema(name: string): SchemaIntrospection | undefined;
    /**
     * Gets all schema names.
     */
    getSchemaNames(): string[];
    /**
     * Gets entity schemas (non-enum).
     */
    getEntitySchemas(): SchemaIntrospection[];
    /**
     * Gets enum schemas.
     */
    getEnumSchemas(): SchemaIntrospection[];
    /**
     * Gets schemas by group.
     */
    getSchemasByGroup(group: string): SchemaIntrospection[];
    /**
     * Gets all unique group names.
     */
    getGroups(): string[];
    /**
     * Introspects a specific schema.
     */
    introspect(name: string): SchemaIntrospection | undefined;
    /**
     * Introspects all schemas.
     */
    introspectAll(): Map<string, SchemaIntrospection>;
    /**
     * Finds schemas that reference a target schema.
     */
    findReferencingSchemas(targetName: string): SchemaIntrospection[];
    /**
     * Finds schemas referenced by a source schema.
     */
    findReferencedSchemas(sourceName: string): SchemaIntrospection[];
    /**
     * Checks if schemas have circular references.
     */
    hasCircularReferences(): boolean;
    /**
     * Gets topological order of schemas (dependencies first).
     */
    getTopologicalOrder(): string[];
    /**
     * Gets the plugin registry.
     */
    getPluginRegistry(): PluginRegistry;
    /**
     * Checks if a type is registered (from plugin).
     */
    hasType(typeName: string): boolean;
    /**
     * Gets custom type names from all registered plugins.
     */
    getCustomTypeNames(): string[];
}
/**
 * Creates an Omnify instance.
 *
 * @example
 * ```typescript
 * const omnify = createOmnify({
 *   schemaDir: './schemas',
 * });
 *
 * const { schemas } = await omnify.load();
 * ```
 */
declare function createOmnify(options: OmnifyOptions): Omnify;

/**
 * @famgia/omnify-core - Schema Metadata Access
 *
 * Utilities for accessing schema metadata programmatically.
 */

/**
 * Extracts metadata from a loaded schema.
 */
declare function getSchemaMetadata(schema: LoadedSchema): SchemaMetadata;
/**
 * Extracts property metadata.
 */
declare function getPropertyMetadata(name: string, property: PropertyDefinition, registry?: PluginRegistry): PropertyMetadata;
/**
 * Extracts association metadata.
 */
declare function getAssociationMetadata(name: string, association: AssociationDefinition): AssociationMetadata;
/**
 * Full schema introspection.
 */
declare function introspectSchema(schema: LoadedSchema, registry?: PluginRegistry): SchemaIntrospection;
/**
 * Introspects all schemas in a collection.
 */
declare function introspectSchemas(schemas: SchemaCollection, registry?: PluginRegistry): Map<string, SchemaIntrospection>;
/**
 * Gets all schema names from a collection.
 */
declare function getSchemaNames(schemas: SchemaCollection): string[];
/**
 * Gets schemas by kind.
 */
declare function getSchemasByKind(schemas: SchemaCollection, kind: 'entity' | 'enum'): LoadedSchema[];
/**
 * Gets entity schemas (non-enum).
 */
declare function getEntitySchemas(schemas: SchemaCollection): LoadedSchema[];
/**
 * Gets enum schemas.
 */
declare function getEnumSchemas(schemas: SchemaCollection): LoadedSchema[];
/**
 * Gets schemas by group.
 */
declare function getSchemasByGroup(schemas: SchemaCollection, group: string): LoadedSchema[];
/**
 * Gets all unique group names.
 */
declare function getGroups(schemas: SchemaCollection): string[];
/**
 * Finds schemas that reference a target schema.
 */
declare function findReferencingSchemas(schemas: SchemaCollection, targetName: string): LoadedSchema[];
/**
 * Finds schemas referenced by a source schema.
 */
declare function findReferencedSchemas(schemas: SchemaCollection, sourceName: string): LoadedSchema[];
/**
 * Gets the relationship graph as adjacency list.
 */
declare function getRelationshipGraph(schemas: SchemaCollection): Map<string, string[]>;
/**
 * Checks if schemas form a valid DAG (no circular references).
 */
declare function hasCircularReferences(schemas: SchemaCollection): boolean;
/**
 * Gets topological sort order for schemas (dependencies first).
 */
declare function getTopologicalOrder(schemas: SchemaCollection): string[];

/**
 * @famgia/omnify-core - Version History Types
 *
 * Types for tracking schema versions and changes over time.
 */
/**
 * Property snapshot for version file.
 */
interface VersionPropertySnapshot {
    readonly type: string;
    readonly displayName?: string;
    readonly description?: string;
    readonly nullable?: boolean;
    readonly unique?: boolean;
    readonly default?: unknown;
    readonly length?: number;
    readonly unsigned?: boolean;
    readonly precision?: number;
    readonly scale?: number;
    readonly enum?: readonly string[];
    readonly relation?: string;
    readonly target?: string;
    readonly targets?: readonly string[];
    readonly morphName?: string;
    readonly onDelete?: string;
    readonly onUpdate?: string;
    readonly mappedBy?: string;
    readonly inversedBy?: string;
    readonly joinTable?: string;
    readonly owning?: boolean;
    /** Laravel: hidden in serialization */
    readonly hidden?: boolean;
    /** Laravel: mass assignable */
    readonly fillable?: boolean;
    /** Per-field overrides for compound types */
    readonly fields?: Record<string, {
        nullable?: boolean;
        hidden?: boolean;
        fillable?: boolean;
    }>;
}
/**
 * Index snapshot for version file.
 */
interface VersionIndexSnapshot {
    readonly columns: readonly string[];
    readonly unique?: boolean;
    readonly name?: string;
    readonly type?: string;
}
/**
 * Schema snapshot for version file.
 */
interface VersionSchemaSnapshot {
    readonly name: string;
    readonly kind: 'object' | 'enum' | 'partial' | 'pivot';
    readonly displayName?: string;
    readonly singular?: string;
    readonly plural?: string;
    readonly titleIndex?: string;
    readonly group?: string;
    readonly properties?: Record<string, VersionPropertySnapshot>;
    readonly values?: readonly string[];
    readonly options?: {
        readonly id?: boolean;
        readonly idType?: string;
        readonly timestamps?: boolean;
        readonly softDelete?: boolean;
        readonly tableName?: string;
        readonly indexes?: readonly VersionIndexSnapshot[];
        readonly translations?: boolean;
        readonly authenticatable?: boolean;
    };
}
/**
 * Change action types.
 */
type ChangeAction = 'initial' | 'schema_added' | 'schema_removed' | 'schema_modified' | 'property_added' | 'property_removed' | 'property_modified' | 'property_renamed' | 'index_added' | 'index_removed' | 'index_modified' | 'option_changed';
/**
 * A single change record.
 */
interface VersionChange {
    readonly action: ChangeAction;
    readonly schema?: string;
    readonly property?: string;
    readonly index?: string;
    readonly from?: unknown;
    readonly to?: unknown;
    readonly details?: Record<string, unknown>;
}
/**
 * Version file structure.
 * Each version file contains full snapshot + changes from previous version.
 */
interface VersionFile {
    /** Version number (1, 2, 3, ...) */
    readonly version: number;
    /** Timestamp when this version was created */
    readonly timestamp: string;
    /** Database driver used */
    readonly driver: string;
    /** Migration file name associated with this version */
    readonly migration?: string;
    /** Description/notes for this version */
    readonly description?: string;
    /** Changes from previous version */
    readonly changes: readonly VersionChange[];
    /** Full schema snapshot at this version */
    readonly snapshot: Record<string, VersionSchemaSnapshot>;
}
/**
 * Version summary (for listing without loading full snapshot).
 */
interface VersionSummary {
    readonly version: number;
    readonly timestamp: string;
    readonly migration?: string;
    readonly description?: string;
    readonly schemaCount: number;
    readonly changeCount: number;
}
/**
 * Result of comparing two versions.
 */
interface VersionDiff {
    readonly fromVersion: number;
    readonly toVersion: number;
    readonly changes: readonly VersionChange[];
}
/**
 * Options for creating a new version.
 */
interface CreateVersionOptions {
    readonly driver: string;
    readonly migration?: string;
    readonly description?: string;
}
/**
 * Version store configuration.
 */
interface VersionStoreConfig {
    /** Base directory for .omnify folder */
    readonly baseDir: string;
    /** Maximum versions to keep (0 = unlimited) */
    readonly maxVersions?: number;
}

/**
 * @famgia/omnify-core - Version Store
 *
 * Manages version history files for schema tracking.
 */

/**
 * Version Store class for managing schema version history.
 */
declare class VersionStore {
    private readonly omnifyDir;
    private readonly versionsDir;
    private readonly maxVersions;
    constructor(config: VersionStoreConfig);
    /**
     * Initialize the version store directory structure.
     */
    initialize(): Promise<void>;
    /**
     * Get the path to the versions directory.
     */
    getVersionsDir(): string;
    /**
     * Get the path to a specific version file.
     */
    getVersionPath(version: number, migration?: string): string;
    /**
     * List all available versions.
     */
    listVersions(): Promise<VersionSummary[]>;
    /**
     * Get the latest version number.
     */
    getLatestVersion(): Promise<number>;
    /**
     * Read a specific version file.
     */
    readVersion(version: number): Promise<VersionFile | null>;
    /**
     * Read the latest version file.
     */
    readLatestVersion(): Promise<VersionFile | null>;
    /**
     * Create a new version.
     */
    createVersion(snapshot: Record<string, VersionSchemaSnapshot>, changes: readonly VersionChange[], options: CreateVersionOptions): Promise<VersionFile>;
    /**
     * Update the current.lock file to point to latest version.
     */
    private updateCurrentLink;
    /**
     * Cleanup old versions beyond maxVersions limit.
     */
    private cleanupOldVersions;
    /**
     * Get diff between two versions.
     */
    diffVersions(fromVersion: number, toVersion: number): Promise<VersionDiff | null>;
    /**
     * Compute changes between two snapshots.
     */
    computeSnapshotDiff(from: Record<string, VersionSchemaSnapshot>, to: Record<string, VersionSchemaSnapshot>): VersionChange[];
    /**
     * Get snapshot at a specific version (for rollback).
     */
    getSnapshotAt(version: number): Promise<Record<string, VersionSchemaSnapshot> | null>;
}
/**
 * Create a new VersionStore instance.
 */
declare function createVersionStore(config: VersionStoreConfig): VersionStore;

/**
 * AI Adapter Types
 *
 * 各AIモデル用のアダプターインターフェース定義
 */
/**
 * ガイドのメタデータ
 */
interface GuideMetadata {
    /** ガイドの一意識別子 */
    id: string;
    /** ソースファイルのパス (knowledge/からの相対パス) */
    source: string;
    /** カテゴリ (guides/omnify, guides/laravel, etc.) */
    category: string;
    /** ガイドの説明 (Cursorのfrontmatter用) */
    description?: string;
    /** 適用するglobパターン (Cursor用) */
    globs?: string[];
    /** 常に適用するか (Cursor用) */
    alwaysApply?: boolean;
}
/**
 * AIモデル別のターゲット設定
 */
interface AITargetConfig {
    /** このターゲットを有効にするか */
    enabled: boolean;
    /** 出力ファイル名 */
    filename?: string;
    /** カスタム設定 */
    [key: string]: unknown;
}
/**
 * ガイドのルール設定
 */
interface GuideRule {
    /** ガイドの一意識別子 */
    id: string;
    /** ソースファイル (knowledge/からの相対パス) */
    source: string;
    /** カテゴリ (出力ディレクトリ構造) */
    category: string;
    /** AIターゲット別の設定 */
    targets: {
        cursor?: CursorTargetConfig;
        claude?: ClaudeTargetConfig;
        antigravity?: AITargetConfig;
        [key: string]: AITargetConfig | undefined;
    };
}
/**
 * Cursor専用のターゲット設定
 */
interface CursorTargetConfig extends AITargetConfig {
    /** ガイドの説明 (frontmatter用) */
    description?: string;
    /** 適用するglobパターン */
    globs?: string[];
    /** 常に適用するか */
    alwaysApply?: boolean;
}
/**
 * Claude専用のターゲット設定
 */
interface ClaudeTargetConfig extends AITargetConfig {
    /** 出力サブディレクトリ */
    subdir?: string;
}
/**
 * 直接コピーするルール (frontmatter付きなど)
 */
interface DirectCopyRule {
    /** ソースファイル */
    source: string;
    /** 優先度 (Antigravity用) */
    priority?: 'high' | 'medium' | 'low';
    /** タグ (Antigravity用) */
    tags?: string[];
}
/**
 * ルール設定ファイルの全体構造
 */
interface RulesConfig {
    /** バージョン */
    version: string;
    /** プレースホルダー定義 */
    placeholders: Record<string, string>;
    /** ガイドルールのリスト */
    guides: GuideRule[];
    /** Cursor用の直接コピールール */
    cursorRules?: DirectCopyRule[];
    /** Claude用の直接コピールール */
    claudeRules?: DirectCopyRule[];
    /** Antigravity用の直接コピールール */
    antigravityRules?: DirectCopyRule[];
}
/**
 * AIアダプターのインターフェース
 */
interface AIAdapter {
    /** アダプター名 */
    readonly name: string;
    /** 出力ディレクトリ (プロジェクトルートからの相対パス) */
    readonly outputDir: string;
    /**
     * コンテンツをこのAIモデル用に変換
     * @param content ソースコンテンツ
     * @param rule ガイドルール
     * @param placeholders プレースホルダー値
     * @returns 変換後のコンテンツ
     */
    transform(content: string, rule: GuideRule, placeholders: Record<string, string>): string;
    /**
     * 出力ファイル名を取得
     * @param rule ガイドルール
     * @returns ファイル名
     */
    getFilename(rule: GuideRule): string;
    /**
     * このガイドがこのアダプターで有効かどうか
     * @param rule ガイドルール
     * @returns 有効ならtrue
     */
    isEnabled(rule: GuideRule): boolean;
    /**
     * 出力パスを取得 (category含む)
     * @param rule ガイドルール
     * @returns 出力パス
     */
    getOutputPath(rule: GuideRule): string;
}
/**
 * AI Guides生成結果
 */
interface AIGuidesResult {
    /** 生成されたファイル数 (アダプター別) */
    counts: Record<string, number>;
    /** 生成されたファイルのパスリスト */
    files: string[];
    /** エラーがあった場合 */
    errors?: string[];
}
/**
 * AI Guides生成オプション
 */
interface AIGuidesOptions {
    /** プレースホルダー値 */
    placeholders?: Record<string, string>;
    /** 使用するアダプター (指定しない場合は全て) */
    adapters?: string[];
    /** ドライラン (ファイルを実際に書き込まない) */
    dryRun?: boolean;
}

/**
 * Cursor AI Adapter
 *
 * Cursorエディタ用のルールファイル生成アダプター
 * .mdc形式でfrontmatter付きのファイルを生成
 */

/**
 * Cursor用アダプター
 */
declare const cursorAdapter: AIAdapter;

/**
 * Claude AI Adapter
 *
 * Claude Code用のガイドファイル生成アダプター
 * .md形式で.claude/omnify/配下にファイルを生成
 */

/**
 * Claude用アダプター
 */
declare const claudeAdapter: AIAdapter;

/**
 * Antigravity AI Adapter
 *
 * Antigravity AI用のルールファイル生成アダプター
 * .md形式でYAML frontmatter付きのファイルを生成
 */

/**
 * Antigravity専用のターゲット設定
 */
interface AntigravityTargetConfig extends AITargetConfig {
    /** ガイドの説明 */
    description?: string;
    /** 適用するglobパターン */
    globs?: string[];
    /** 優先度 (high, medium, low) */
    priority?: 'high' | 'medium' | 'low';
    /** タグ */
    tags?: string[];
}
/**
 * Antigravity用アダプター
 * Official docs: https://antigravity.im/documentation
 * Rules location: .agent/rules/
 */
declare const antigravityAdapter: AIAdapter;

/**
 * AI Adapters
 *
 * 各AIモデル用のアダプターをエクスポート
 */

/**
 * 利用可能な全アダプター
 */
declare const allAdapters: AIAdapter[];
/**
 * 名前でアダプターを取得
 */
declare function getAdapter(name: string): AIAdapter | undefined;
/**
 * 指定した名前のアダプターのみ取得
 */
declare function getAdapters(names?: string[]): AIAdapter[];

/**
 * AI Guides Generator
 *
 * Knowledge Baseからガイドを読み込み、各AIアダプターで変換して出力
 */

/**
 * AI Guidesを生成
 */
declare function generateAIGuides(rootDir: string, options?: AIGuidesOptions): AIGuidesResult;
/**
 * AI Guidesが生成済みかチェック
 */
declare function shouldGenerateAIGuides(rootDir: string): boolean;
/**
 * 利用可能なアダプター名のリストを取得
 */
declare function getAvailableAdapters(): string[];

export { type AIAdapter, type AIGuidesOptions, type AIGuidesResult, type AITargetConfig, type AntigravityTargetConfig, type AssociationMetadata, type ChangeAction, type ClaudeTargetConfig, type CreateVersionOptions, type CursorTargetConfig, type DefaultValueValidationResult, type DiffOperationResult, type ExpandedProperty, FILE_SCHEMA_NAME, type FormatOptions, type GenerateOptions, type GenerateResult, type GeneratedFile, type GuideMetadata, type GuideRule, type LoadResult, type LoadSchemaOptions, type LoadSchemasOptions, Omnify, OmnifyError, type OmnifyLogger, type OmnifyOptions, PluginManager, type PluginManagerOptions, type PluginRegistrationResult, type PluginRegistry, type PropertyMetadata, type RegisteredType, type RulesConfig, type SchemaError, type SchemaIntrospection, type SchemaMetadata, type SchemaValidationResult, type SchemaWarning, type ValidationOptions, type ValidationResult, type VersionChange, type VersionDiff, type VersionFile, type VersionIndexSnapshot, type VersionPropertySnapshot, type VersionSchemaSnapshot, VersionStore, type VersionStoreConfig, type VersionSummary, allAdapters, antigravityAdapter, atlasError, atlasNotFoundError, circularReferenceError, claudeAdapter, configError, configNotFoundError, createFileLoadedSchema, createFileSchemaDefinition, createOmnify, createPluginManager, createVersionStore, cursorAdapter, duplicateSchemaError, ensureFileSchema, expandProperty, expandSchema, expandSchemaProperties, expandSchemas, fileNameToSchemaName, findReferencedSchemas, findReferencingSchemas, formatError, formatErrorPlain, formatErrorSummary, generateAIGuides, generateFileSchemaYaml, generationError, getAdapter, getAdapters, getAssociationMetadata, getAvailableAdapters, getCustomTypeNames, getEntitySchemas, getEnumSchemas, getExitCode, getGroups, getPropertyMetadata, getRelationshipGraph, getSchemaMetadata, getSchemaNames, getSchemasByGroup, getSchemasByKind, getTopologicalOrder, getTypeInfo, hasCircularReferences, internalError, introspectSchema, introspectSchemas, invalidAssociationTargetError, invalidConfigError, invalidPropertyTypeError, isCompoundType, jsonSyntaxError, loadSchema, loadSchemas, mergePartialSchemas, missingConfigFieldError, missingFieldError, notImplementedError, outputWriteError, parseJsonSchema, parseYamlSchema, pluginError, pluginNotFoundError, pluginTypeConflictError, schemaNotFoundError, schemaParseError, schemasHaveFileProperties, shouldGenerateAIGuides, validateAssociations, validateDefaultValue, validateEnumSchema, validateOptions, validateProperties, validatePropertyType, validateSchema, validateSchemas, validationError, yamlSyntaxError };
