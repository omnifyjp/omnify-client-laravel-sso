#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/index.ts
var import_server = require("@modelcontextprotocol/sdk/server/index.js");
var import_stdio = require("@modelcontextprotocol/sdk/server/stdio.js");
var import_types = require("@modelcontextprotocol/sdk/types.js");
var import_zod = require("zod");
var yaml = __toESM(require("yaml"), 1);
var PropertyTypeEnum = import_zod.z.enum([
  "String",
  "Int",
  "BigInt",
  "Float",
  "Decimal",
  "Boolean",
  "Text",
  "LongText",
  "Date",
  "Time",
  "Timestamp",
  "Json",
  "Email",
  "Password",
  "File",
  "Point",
  "Coordinates",
  "Enum",
  "EnumRef",
  "Association"
]);
var RelationTypeEnum = import_zod.z.enum([
  "OneToOne",
  "OneToMany",
  "ManyToOne",
  "ManyToMany",
  "MorphTo",
  "MorphOne",
  "MorphMany",
  "MorphToMany",
  "MorphedByMany"
]);
var ReferentialActionEnum = import_zod.z.enum([
  "CASCADE",
  "SET NULL",
  "SET DEFAULT",
  "RESTRICT",
  "NO ACTION"
]);
var LocalizedStringSchema = import_zod.z.union([
  import_zod.z.string(),
  import_zod.z.record(import_zod.z.string(), import_zod.z.string())
]);
var CreateSchemaInputSchema = import_zod.z.object({
  name: import_zod.z.string().describe("Schema name in PascalCase (e.g., User, BlogPost)"),
  kind: import_zod.z.enum(["object", "enum"]).default("object").describe("Schema kind"),
  displayName: LocalizedStringSchema.optional().describe("Human-readable name (string or locale map)"),
  group: import_zod.z.string().optional().describe("Schema group for organization"),
  properties: import_zod.z.record(import_zod.z.string(), import_zod.z.object({
    type: PropertyTypeEnum,
    displayName: LocalizedStringSchema.optional(),
    placeholder: LocalizedStringSchema.optional().describe("Placeholder text for form inputs (string or locale map)"),
    nullable: import_zod.z.boolean().optional(),
    unique: import_zod.z.boolean().optional(),
    default: import_zod.z.unknown().optional(),
    length: import_zod.z.number().optional(),
    unsigned: import_zod.z.boolean().optional(),
    precision: import_zod.z.number().optional(),
    scale: import_zod.z.number().optional(),
    enum: import_zod.z.union([import_zod.z.string(), import_zod.z.array(import_zod.z.unknown())]).optional(),
    relation: RelationTypeEnum.optional(),
    target: import_zod.z.string().optional(),
    onDelete: ReferentialActionEnum.optional(),
    joinTable: import_zod.z.string().optional(),
    multiple: import_zod.z.boolean().optional(),
    fields: import_zod.z.record(import_zod.z.string(), import_zod.z.object({
      nullable: import_zod.z.boolean().optional(),
      hidden: import_zod.z.boolean().optional(),
      fillable: import_zod.z.boolean().optional(),
      length: import_zod.z.number().optional(),
      placeholder: LocalizedStringSchema.optional()
    })).optional().describe("Per-field overrides for compound types")
  })).optional(),
  values: import_zod.z.array(import_zod.z.union([
    import_zod.z.string(),
    import_zod.z.object({
      value: import_zod.z.string(),
      label: LocalizedStringSchema.optional()
    })
  ])).optional().describe("Enum values (only for kind: enum)"),
  options: import_zod.z.object({
    softDelete: import_zod.z.boolean().optional(),
    timestamps: import_zod.z.boolean().optional(),
    authenticatable: import_zod.z.boolean().optional(),
    tableName: import_zod.z.string().optional(),
    idType: import_zod.z.enum(["BigInt", "Int", "Uuid", "String"]).optional()
  }).optional()
});
function getPropertyTypes() {
  return `# Omnify Property Types

## Primitive Types
- **String**: VARCHAR(255) - short text, use \`length\` for custom size
- **Int**: INTEGER - 32-bit integer
- **BigInt**: BIGINT - 64-bit integer (default for IDs)
- **Float**: FLOAT - floating point number
- **Decimal**: DECIMAL(precision, scale) - exact decimal, use for money
- **Boolean**: BOOLEAN - true/false

## Text Types
- **Text**: TEXT (~65KB) - medium text content
- **LongText**: LONGTEXT (~4GB) - large text content

## Date/Time Types
- **Date**: DATE - date only (YYYY-MM-DD)
- **Time**: TIME - time only (HH:MM:SS)
- **Timestamp**: TIMESTAMP - date and time

## Special Types
- **Email**: VARCHAR(255) - validated email format
- **Password**: VARCHAR(255) - hashed password (auto-hidden)
- **Json**: JSON - structured data
- **File**: Polymorphic file attachment

## Enum Types
- **Enum**: Inline enum values
- **EnumRef**: Reference to shared enum schema

## Association Types (Relations)
- **Association**: Relationship to another schema
  - relation: OneToOne, OneToMany, ManyToOne, ManyToMany
  - relation: MorphTo, MorphOne, MorphMany (polymorphic)
  - target: Target schema name
  - onDelete: CASCADE, SET NULL, RESTRICT
`;
}
function getRelationshipGuide() {
  return `# Omnify Relationship Guide

## Standard Relations

### ManyToOne (belongs to)
Most common - creates foreign key column.
\`\`\`yaml
author:
  type: Association
  relation: ManyToOne
  target: User
  onDelete: CASCADE
\`\`\`

### OneToMany (has many)
Inverse of ManyToOne - no column created.
\`\`\`yaml
posts:
  type: Association
  relation: OneToMany
  target: Post
\`\`\`

### ManyToMany
Creates pivot table automatically.
\`\`\`yaml
tags:
  type: Association
  relation: ManyToMany
  target: Tag
  joinTable: post_tags  # optional custom name
\`\`\`

### OneToOne
Unique foreign key relationship.
\`\`\`yaml
profile:
  type: Association
  relation: OneToOne
  target: UserProfile
\`\`\`

## Polymorphic Relations

### MorphTo (owning side)
Creates {name}_type and {name}_id columns.
\`\`\`yaml
commentable:
  type: Association
  relation: MorphTo
\`\`\`

### MorphMany (inverse side)
No columns - defines inverse relationship.
\`\`\`yaml
comments:
  type: Association
  relation: MorphMany
  target: Comment
\`\`\`
`;
}
function getExampleSchemas() {
  return `# Omnify Schema Examples

## User Schema (with authentication)
\`\`\`yaml
name: User
displayName:
  ja: \u30E6\u30FC\u30B6\u30FC
  en: User
options:
  softDelete: true
  authenticatable: true
properties:
  name:
    type: String
    displayName:
      ja: \u6C0F\u540D
      en: Full Name
  email:
    type: Email
    unique: true
    displayName:
      ja: \u30E1\u30FC\u30EB\u30A2\u30C9\u30EC\u30B9
      en: Email Address
  password:
    type: Password
  posts:
    type: Association
    relation: OneToMany
    target: Post
\`\`\`

## Post Schema (with relations)
\`\`\`yaml
name: Post
displayName:
  ja: \u6295\u7A3F
  en: Post
options:
  softDelete: true
  indexes:
    - columns: [published_at]
    - columns: [status, published_at]
properties:
  title:
    type: String
    displayName:
      ja: \u30BF\u30A4\u30C8\u30EB
      en: Title
  slug:
    type: String
    unique: true
  content:
    type: LongText
    displayName:
      ja: \u672C\u6587
      en: Content
  status:
    type: EnumRef
    enum: PostStatus
    default: draft
  published_at:
    type: Timestamp
    nullable: true
  author:
    type: Association
    relation: ManyToOne
    target: User
    onDelete: CASCADE
  category:
    type: Association
    relation: ManyToOne
    target: Category
  tags:
    type: Association
    relation: ManyToMany
    target: Tag
    joinTable: post_tags
  comments:
    type: Association
    relation: MorphMany
    target: Comment
\`\`\`

## Enum Schema
\`\`\`yaml
name: PostStatus
kind: enum
displayName:
  ja: \u6295\u7A3F\u30B9\u30C6\u30FC\u30BF\u30B9
  en: Post Status
values:
  - value: draft
    label:
      ja: \u4E0B\u66F8\u304D
      en: Draft
  - value: pending
    label:
      ja: \u5BE9\u67FB\u4E2D
      en: Pending Review
  - value: published
    label:
      ja: \u516C\u958B\u6E08\u307F
      en: Published
  - value: archived
    label:
      ja: \u30A2\u30FC\u30AB\u30A4\u30D6
      en: Archived
\`\`\`

## Category Schema (self-referencing)
\`\`\`yaml
name: Category
displayName:
  ja: \u30AB\u30C6\u30B4\u30EA
  en: Category
properties:
  name:
    type: String
    length: 100
  slug:
    type: String
    unique: true
  description:
    type: Text
    nullable: true
  parent:
    type: Association
    relation: ManyToOne
    target: Category
    nullable: true
  children:
    type: Association
    relation: OneToMany
    target: Category
  posts:
    type: Association
    relation: OneToMany
    target: Post
\`\`\`
`;
}
function createSchema(input) {
  const schema = {
    name: input.name
  };
  if (input.kind && input.kind !== "object") {
    schema.kind = input.kind;
  }
  if (input.displayName) {
    schema.displayName = input.displayName;
  }
  if (input.group) {
    schema.group = input.group;
  }
  if (input.options && Object.keys(input.options).length > 0) {
    schema.options = input.options;
  }
  if (input.properties && Object.keys(input.properties).length > 0) {
    schema.properties = input.properties;
  }
  if (input.values && input.values.length > 0) {
    schema.values = input.values;
  }
  return yaml.stringify(schema);
}
function validateSchemaYaml(yamlContent) {
  const errors = [];
  const warnings = [];
  try {
    const schema = yaml.parse(yamlContent);
    if (!schema.name) {
      errors.push("Missing required field: name");
    }
    if (schema.kind && !["object", "enum"].includes(schema.kind)) {
      errors.push(`Invalid kind: ${schema.kind}. Must be 'object' or 'enum'`);
    }
    if (schema.kind === "enum") {
      if (!schema.values || schema.values.length === 0) {
        errors.push("Enum schema must have values array");
      }
      if (schema.properties && Object.keys(schema.properties).length > 0) {
        warnings.push("Enum schemas should not have properties");
      }
    }
    if (schema.kind !== "enum") {
      if (schema.values && schema.values.length > 0) {
        warnings.push("Object schemas should not have values (use kind: enum for enums)");
      }
      if (schema.properties) {
        for (const [propName, propDef] of Object.entries(schema.properties)) {
          const prop = propDef;
          if (!prop.type) {
            errors.push(`Property '${propName}' missing required field: type`);
          }
          if (prop.type === "Association") {
            if (!prop.relation) {
              errors.push(`Property '${propName}' (Association) missing required field: relation`);
            }
            if (prop.relation !== "MorphTo" && !prop.target) {
              errors.push(`Property '${propName}' (Association) missing required field: target`);
            }
          }
          if (prop.type === "EnumRef" && !prop.enum) {
            errors.push(`Property '${propName}' (EnumRef) missing required field: enum`);
          }
          if (prop.type === "Enum" && !prop.enum) {
            errors.push(`Property '${propName}' (Enum) missing required field: enum`);
          }
        }
      }
    }
    return { valid: errors.length === 0, errors, warnings };
  } catch (e) {
    return {
      valid: false,
      errors: [`Invalid YAML: ${e instanceof Error ? e.message : "Unknown error"}`],
      warnings: []
    };
  }
}
var server = new import_server.Server(
  {
    name: "omnify-mcp",
    version: "0.0.1"
  },
  {
    capabilities: {
      tools: {},
      resources: {}
    }
  }
);
server.setRequestHandler(import_types.ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "omnify_create_schema",
        description: "Create an Omnify schema YAML file. Use this to generate database models with Laravel and TypeScript support.",
        inputSchema: {
          type: "object",
          properties: {
            name: {
              type: "string",
              description: "Schema name in PascalCase (e.g., User, BlogPost)"
            },
            kind: {
              type: "string",
              enum: ["object", "enum"],
              default: "object",
              description: "Schema kind - object for tables, enum for enumeration types"
            },
            displayName: {
              oneOf: [
                { type: "string" },
                { type: "object", additionalProperties: { type: "string" } }
              ],
              description: 'Human-readable name. Can be string or locale map like { ja: "\u65E5\u672C\u8A9E", en: "English" }'
            },
            group: {
              type: "string",
              description: "Schema group for organization (e.g., auth, blog, shop)"
            },
            properties: {
              type: "object",
              description: "Property definitions. Each property has type and optional modifiers.",
              additionalProperties: {
                type: "object",
                properties: {
                  type: {
                    type: "string",
                    enum: ["String", "Int", "BigInt", "Float", "Decimal", "Boolean", "Text", "LongText", "Date", "Time", "Timestamp", "Json", "Email", "Password", "File", "Enum", "EnumRef", "Association"]
                  },
                  displayName: {
                    oneOf: [
                      { type: "string" },
                      { type: "object", additionalProperties: { type: "string" } }
                    ]
                  },
                  nullable: { type: "boolean" },
                  unique: { type: "boolean" },
                  default: {},
                  length: { type: "number" },
                  enum: { oneOf: [{ type: "string" }, { type: "array" }] },
                  relation: { type: "string", enum: ["OneToOne", "OneToMany", "ManyToOne", "ManyToMany", "MorphTo", "MorphOne", "MorphMany"] },
                  target: { type: "string" },
                  onDelete: { type: "string", enum: ["CASCADE", "SET NULL", "RESTRICT"] },
                  joinTable: { type: "string" }
                }
              }
            },
            values: {
              type: "array",
              description: "Enum values (only for kind: enum)",
              items: {
                oneOf: [
                  { type: "string" },
                  { type: "object", properties: { value: { type: "string" }, label: {} } }
                ]
              }
            },
            options: {
              type: "object",
              properties: {
                softDelete: { type: "boolean", description: "Enable soft deletes" },
                timestamps: { type: "boolean", description: "Add created_at/updated_at" },
                authenticatable: { type: "boolean", description: "Enable for User model" },
                tableName: { type: "string", description: "Custom table name" },
                idType: { type: "string", enum: ["BigInt", "Int", "Uuid", "String"] }
              }
            }
          },
          required: ["name"]
        }
      },
      {
        name: "omnify_validate_schema",
        description: "Validate an Omnify schema YAML content. Returns validation errors and warnings.",
        inputSchema: {
          type: "object",
          properties: {
            yaml_content: {
              type: "string",
              description: "YAML content to validate"
            }
          },
          required: ["yaml_content"]
        }
      },
      {
        name: "omnify_get_types",
        description: "Get documentation for all Omnify property types and their options.",
        inputSchema: {
          type: "object",
          properties: {}
        }
      },
      {
        name: "omnify_get_relationships",
        description: "Get documentation for Omnify relationship types (OneToMany, ManyToOne, ManyToMany, polymorphic, etc.)",
        inputSchema: {
          type: "object",
          properties: {}
        }
      },
      {
        name: "omnify_get_examples",
        description: "Get example Omnify schemas for common use cases (User, Post, Category, Enum)",
        inputSchema: {
          type: "object",
          properties: {}
        }
      }
    ]
  };
});
server.setRequestHandler(import_types.CallToolRequestSchema, async (request) => {
  const { name, arguments: args } = request.params;
  switch (name) {
    case "omnify_create_schema": {
      try {
        const input = CreateSchemaInputSchema.parse(args);
        const yamlContent = createSchema(input);
        return {
          content: [
            {
              type: "text",
              text: `# Generated Schema: ${input.name}

\`\`\`yaml
${yamlContent}\`\`\`

Save this to: schemas/${input.group || "default"}/${input.name}.yaml`
            }
          ]
        };
      } catch (e) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating schema: ${e instanceof Error ? e.message : "Unknown error"}`
            }
          ],
          isError: true
        };
      }
    }
    case "omnify_validate_schema": {
      const yamlContent = args.yaml_content;
      const result = validateSchemaYaml(yamlContent);
      let response = result.valid ? "\u2705 Schema is valid!\n\n" : "\u274C Schema has errors:\n\n";
      if (result.errors.length > 0) {
        response += "**Errors:**\n" + result.errors.map((e) => `- ${e}`).join("\n") + "\n\n";
      }
      if (result.warnings.length > 0) {
        response += "**Warnings:**\n" + result.warnings.map((w) => `- ${w}`).join("\n");
      }
      return {
        content: [{ type: "text", text: response }]
      };
    }
    case "omnify_get_types": {
      return {
        content: [{ type: "text", text: getPropertyTypes() }]
      };
    }
    case "omnify_get_relationships": {
      return {
        content: [{ type: "text", text: getRelationshipGuide() }]
      };
    }
    case "omnify_get_examples": {
      return {
        content: [{ type: "text", text: getExampleSchemas() }]
      };
    }
    default:
      return {
        content: [{ type: "text", text: `Unknown tool: ${name}` }],
        isError: true
      };
  }
});
server.setRequestHandler(import_types.ListResourcesRequestSchema, async () => {
  return {
    resources: [
      {
        uri: "omnify://schema/json-schema",
        name: "Omnify JSON Schema",
        description: "JSON Schema for validating Omnify schema files",
        mimeType: "application/json"
      },
      {
        uri: "omnify://docs/types",
        name: "Property Types Documentation",
        description: "Documentation for all Omnify property types",
        mimeType: "text/markdown"
      },
      {
        uri: "omnify://docs/relationships",
        name: "Relationships Documentation",
        description: "Documentation for Omnify relationship types",
        mimeType: "text/markdown"
      },
      {
        uri: "omnify://examples/all",
        name: "Schema Examples",
        description: "Example schemas for common use cases",
        mimeType: "text/markdown"
      }
    ]
  };
});
server.setRequestHandler(import_types.ReadResourceRequestSchema, async (request) => {
  const { uri } = request.params;
  switch (uri) {
    case "omnify://docs/types":
      return {
        contents: [{ uri, mimeType: "text/markdown", text: getPropertyTypes() }]
      };
    case "omnify://docs/relationships":
      return {
        contents: [{ uri, mimeType: "text/markdown", text: getRelationshipGuide() }]
      };
    case "omnify://examples/all":
      return {
        contents: [{ uri, mimeType: "text/markdown", text: getExampleSchemas() }]
      };
    default:
      throw new Error(`Unknown resource: ${uri}`);
  }
});
async function main() {
  const transport = new import_stdio.StdioServerTransport();
  await server.connect(transport);
  console.error("Omnify MCP Server running on stdio");
}
main().catch(console.error);
//# sourceMappingURL=index.cjs.map